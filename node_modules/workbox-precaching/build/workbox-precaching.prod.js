<<<<<<< HEAD
this.workbox=this.workbox||{},this.workbox.precaching=function(t,e,s,n,i,c,r,o){"use strict";try{self["workbox:precaching:6.5.3"]&&_()}catch(t){}function a(t){if(!t)throw new s.WorkboxError("add-to-cache-list-unexpected-type",{entry:t});if("string"==typeof t){const e=new URL(t,location.href);return{cacheKey:e.href,url:e.href}}const{revision:e,url:n}=t;if(!n)throw new s.WorkboxError("add-to-cache-list-unexpected-type",{entry:t});if(!e){const t=new URL(n,location.href);return{cacheKey:t.href,url:t.href}}const i=new URL(n,location.href),c=new URL(n,location.href);return i.searchParams.set("__WB_REVISION__",e),{cacheKey:i.href,url:c.href}}class h{constructor(){this.updatedURLs=[],this.notUpdatedURLs=[],this.handlerWillStart=async({request:t,state:e})=>{e&&(e.originalRequest=t)},this.cachedResponseWillBeUsed=async({event:t,state:e,cachedResponse:s})=>{if("install"===t.type&&e&&e.originalRequest&&e.originalRequest instanceof Request){const t=e.originalRequest.url;s?this.notUpdatedURLs.push(t):this.updatedURLs.push(t)}return s}}}class l{constructor({precacheController:t}){this.cacheKeyWillBeUsed=async({request:t,params:e})=>{const s=(null==e?void 0:e.cacheKey)||this.tt.getCacheKeyForURL(t.url);return s?new Request(s,{headers:t.headers}):t},this.tt=t}}class u extends c.Strategy{constructor(t={}){t.cacheName=e.cacheNames.getPrecacheName(t.cacheName),super(t),this.et=!1!==t.fallbackToNetwork,this.plugins.push(u.copyRedirectedCacheableResponsesPlugin)}async _handle(t,e){const s=await e.cacheMatch(t);return s||(e.event&&"install"===e.event.type?await this.st(t,e):await this.nt(t,e))}async nt(t,e){let n;const i=e.params||{};if(!this.et)throw new s.WorkboxError("missing-precache-entry",{cacheName:this.cacheName,url:t.url});{const s=i.integrity,c=t.integrity,r=!c||c===s;n=await e.fetch(new Request(t,{integrity:"no-cors"!==t.mode?c||s:void 0})),s&&r&&"no-cors"!==t.mode&&(this.it(),await e.cachePut(t,n.clone()))}return n}async st(t,e){this.it();const n=await e.fetch(t);if(!await e.cachePut(t,n.clone()))throw new s.WorkboxError("bad-precaching-response",{url:t.url,status:n.status});return n}it(){let t=null,e=0;for(const[s,n]of this.plugins.entries())n!==u.copyRedirectedCacheableResponsesPlugin&&(n===u.defaultPrecacheCacheabilityPlugin&&(t=s),n.cacheWillUpdate&&e++);0===e?this.plugins.push(u.defaultPrecacheCacheabilityPlugin):e>1&&null!==t&&this.plugins.splice(t,1)}}u.defaultPrecacheCacheabilityPlugin={cacheWillUpdate:async({response:t})=>!t||t.status>=400?null:t},u.copyRedirectedCacheableResponsesPlugin={cacheWillUpdate:async({response:t})=>t.redirected?await i.copyResponse(t):t};class f{constructor({cacheName:t,plugins:s=[],fallbackToNetwork:n=!0}={}){this.ct=new Map,this.rt=new Map,this.ot=new Map,this.at=new u({cacheName:e.cacheNames.getPrecacheName(t),plugins:[...s,new l({precacheController:this})],fallbackToNetwork:n}),this.install=this.install.bind(this),this.activate=this.activate.bind(this)}get strategy(){return this.at}precache(t){this.addToCacheList(t),this.ht||(self.addEventListener("install",this.install),self.addEventListener("activate",this.activate),this.ht=!0)}addToCacheList(t){const e=[];for(const n of t){"string"==typeof n?e.push(n):n&&void 0===n.revision&&e.push(n.url);const{cacheKey:t,url:i}=a(n),c="string"!=typeof n&&n.revision?"reload":"default";if(this.ct.has(i)&&this.ct.get(i)!==t)throw new s.WorkboxError("add-to-cache-list-conflicting-entries",{firstEntry:this.ct.get(i),secondEntry:t});if("string"!=typeof n&&n.integrity){if(this.ot.has(t)&&this.ot.get(t)!==n.integrity)throw new s.WorkboxError("add-to-cache-list-conflicting-integrities",{url:i});this.ot.set(t,n.integrity)}if(this.ct.set(i,t),this.rt.set(i,c),e.length>0){const t=`Workbox is precaching URLs without revision info: ${e.join(", ")}\nThis is generally NOT safe. Learn more at https://bit.ly/wb-precache`;console.warn(t)}}}install(t){return n.waitUntil(t,(async()=>{const e=new h;this.strategy.plugins.push(e);for(const[e,s]of this.ct){const n=this.ot.get(s),i=this.rt.get(e),c=new Request(e,{integrity:n,cache:i,credentials:"same-origin"});await Promise.all(this.strategy.handleAll({params:{cacheKey:s},request:c,event:t}))}const{updatedURLs:s,notUpdatedURLs:n}=e;return{updatedURLs:s,notUpdatedURLs:n}}))}activate(t){return n.waitUntil(t,(async()=>{const t=await self.caches.open(this.strategy.cacheName),e=await t.keys(),s=new Set(this.ct.values()),n=[];for(const i of e)s.has(i.url)||(await t.delete(i),n.push(i.url));return{deletedURLs:n}}))}getURLsToCacheKeys(){return this.ct}getCachedURLs(){return[...this.ct.keys()]}getCacheKeyForURL(t){const e=new URL(t,location.href);return this.ct.get(e.href)}getIntegrityForCacheKey(t){return this.ot.get(t)}async matchPrecache(t){const e=t instanceof Request?t.url:t,s=this.getCacheKeyForURL(e);if(s){return(await self.caches.open(this.strategy.cacheName)).match(s)}}createHandlerBoundToURL(t){const e=this.getCacheKeyForURL(t);if(!e)throw new s.WorkboxError("non-precached-url",{url:t});return s=>(s.request=new Request(t),s.params=Object.assign({cacheKey:e},s.params),this.strategy.handle(s))}}let w;const d=()=>(w||(w=new f),w);class y extends o.Route{constructor(t,e){super((({request:s})=>{const n=t.getURLsToCacheKeys();for(const i of function*(t,{ignoreURLParametersMatching:e=[/^utm_/,/^fbclid$/],directoryIndex:s="index.html",cleanURLs:n=!0,urlManipulation:i}={}){const c=new URL(t,location.href);c.hash="",yield c.href;const r=function(t,e=[]){for(const s of[...t.searchParams.keys()])e.some((t=>t.test(s)))&&t.searchParams.delete(s);return t}(c,e);if(yield r.href,s&&r.pathname.endsWith("/")){const t=new URL(r.href);t.pathname+=s,yield t.href}if(n){const t=new URL(r.href);t.pathname+=".html",yield t.href}if(i){const t=i({url:c});for(const e of t)yield e.href}}(s.url,e)){const e=n.get(i);if(e){return{cacheKey:e,integrity:t.getIntegrityForCacheKey(e)}}}}),t.strategy)}}function p(t){const e=d(),s=new y(e,t);r.registerRoute(s)}function R(t){d().precache(t)}return t.PrecacheController=f,t.PrecacheFallbackPlugin=class{constructor({fallbackURL:t,precacheController:e}){this.handlerDidError=()=>this.tt.matchPrecache(this.lt),this.lt=t,this.tt=e||d()}},t.PrecacheRoute=y,t.PrecacheStrategy=u,t.addPlugins=function(t){d().strategy.plugins.push(...t)},t.addRoute=p,t.cleanupOutdatedCaches=function(){self.addEventListener("activate",(t=>{const s=e.cacheNames.getPrecacheName();t.waitUntil((async(t,e="-precache-")=>{const s=(await self.caches.keys()).filter((s=>s.includes(e)&&s.includes(self.registration.scope)&&s!==t));return await Promise.all(s.map((t=>self.caches.delete(t)))),s})(s).then((t=>{})))}))},t.createHandlerBoundToURL=function(t){return d().createHandlerBoundToURL(t)},t.getCacheKeyForURL=function(t){return d().getCacheKeyForURL(t)},t.matchPrecache=function(t){return d().matchPrecache(t)},t.precache=R,t.precacheAndRoute=function(t,e){R(t),p(e)},t}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core,workbox.strategies,workbox.routing,workbox.routing);
=======
this.workbox=this.workbox||{},this.workbox.precaching=function(e,t,n,r,s){"use strict";try{self.workbox.v["workbox:precaching:3.6.3"]=1}catch(e){}class i{constructor(e,t,n,r){this.e=e,this.t=t,this.n=n;const s=new Request(t,{credentials:"same-origin"});this.r=s,this.s=r?this.i(s):s}i(e){let t=e.url;const n={credentials:"same-origin"};if("cache"in Request.prototype)n.cache="reload";else{const e=new URL(t,location),n=encodeURIComponent;e.search+=(e.search?"&":"")+n("_workbox-cache-bust")+"="+n(this.n),t=e.toString()}return new Request(t,n)}}const c="revision",o="url",l="precached-details-models";class a{constructor(t){const n=t.replace(/[^\w-]/g,"_");this.c=new e.DBWrapper(n,2,{onupgradeneeded:this.o})}o(e){const t=e.target.result;e.oldVersion<2&&(t.objectStoreNames.contains("workbox-precaching")&&t.deleteObjectStore("workbox-precaching"),t.objectStoreNames.contains(l)&&t.deleteObjectStore(l)),t.createObjectStore(l)}l(e,t){var n=this;return babelHelpers.asyncToGenerator(function*(){return(yield n.a(t.t))===t.n&&!!(yield(yield caches.open(e)).match(t.r))})()}u(){var e=this;return babelHelpers.asyncToGenerator(function*(){return yield e.c.getAllMatching(l,{includeKeys:!0})})()}a(e){var t=this;return babelHelpers.asyncToGenerator(function*(){const n=yield t.c.get(l,e);return n?n[c]:null})()}d(e){var t=this;return babelHelpers.asyncToGenerator(function*(){yield t.c.put(l,{[c]:e.n,[o]:e.r.url},e.t)})()}h(e){var t=this;return babelHelpers.asyncToGenerator(function*(){yield t.c.delete(l,e)})()}}const u=(d=babelHelpers.asyncToGenerator(function*(e){const t=e.clone(),n=yield"body"in t?Promise.resolve(t.body):t.blob();return new Response(n,{headers:t.headers,status:t.status,statusText:t.statusText})}),function(e){return d.apply(this,arguments)});var d;class h{constructor(e){this.p=t.cacheNames.getPrecacheName(e),this.f=new Map,this.y=new a(this.p)}addToCacheList(e){e.map(e=>{this.b(this.w(e))})}w(e){switch(typeof e){case"string":return new i(e,e,e);case"object":return new i(e,e.url,e.revision||e.url,!!e.revision);default:throw new n.WorkboxError("add-to-cache-list-unexpected-type",{entry:e})}}b(e){const t=this.f.get(e.t);if(t){if(t.n!==e.n)throw new n.WorkboxError("add-to-cache-list-conflicting-entries",{firstEntry:t.e,secondEntry:e.e})}else this.f.set(e.t,e)}install({suppressWarnings:e=!1,event:t,plugins:n}={}){var r=this;return babelHelpers.asyncToGenerator(function*(){const e=yield caches.open(r.g()),s=yield e.keys();yield Promise.all(s.map(function(t){return e.delete(t)}));const i=[],c=[];for(const e of r.f.values())(yield r.y.l(r.p,e))?c.push(e):i.push(e);return yield Promise.all(i.map(function(e){return r.m({event:t,plugins:n,precacheEntry:e})})),{updatedEntries:i,notUpdatedEntries:c}})()}activate(e={}){var t=this;return babelHelpers.asyncToGenerator(function*(){const n=yield caches.open(t.g()),r=yield n.keys();for(const i of r){const r=yield n.match(i);yield s.cacheWrapper.put({cacheName:t.p,request:i,response:r,plugins:e.plugins}),yield n.delete(i)}return t.R()})()}g(){return`${this.p}-temp`}m({precacheEntry:e,event:t,plugins:n}){var i=this;return babelHelpers.asyncToGenerator(function*(){let c=yield r.fetchWrapper.fetch({request:e.s,event:t,fetchOptions:null,plugins:n});return c.redirected&&(c=yield u(c)),yield s.cacheWrapper.put({cacheName:i.g(),request:e.r,response:c,event:t,plugins:n}),yield i.y.d(e),!0})()}R(){var e=this;return babelHelpers.asyncToGenerator(function*(){const t=[];e.f.forEach(function(e){const n=new URL(e.r.url,location).toString();t.push(n)});const[n,r]=yield Promise.all([e._(t),e.U(t)]);return{deletedCacheRequests:n,deletedRevisionDetails:r}})()}_(e){var t=this;return babelHelpers.asyncToGenerator(function*(){if(!(yield caches.has(t.p)))return[];const n=yield caches.open(t.p),r=(yield n.keys()).filter(function(t){return!e.includes(new URL(t.url,location).toString())});return yield Promise.all(r.map(function(e){return n.delete(e)})),r.map(function(e){return e.url})})()}U(e){var t=this;return babelHelpers.asyncToGenerator(function*(){const n=(yield t.y.u()).filter(function(t){const n=new URL(t.value.url,location).toString();return!e.includes(n)});return yield Promise.all(n.map(function(e){return t.y.h(e.primaryKey)})),n.map(function(e){return e.value.url})})()}getCachedUrls(){return Array.from(this.f.keys()).map(e=>new URL(e,location).href)}}var p=Object.freeze({PrecacheController:h});let f=!1,y=!1,b=!1,w=[];const g=t.cacheNames.getPrecacheName(),v=new h(g),m=(e,{ignoreUrlParametersMatching:t=[/^utm_/],directoryIndex:n="index.html",cleanUrls:r=!0,urlManipulation:s=null}={})=>{const i=new URL(e,location);i.hash="";const c=((e,t)=>{const n=e.search.slice(1).split("&").map(e=>e.split("=")).filter(e=>t.every(t=>!t.test(e[0]))).map(e=>e.join("=")),r=new URL(e);return r.search=n.join("&"),r})(i,t);let o=[i,c];if(n&&c.pathname.endsWith("/")){const e=new URL(c);e.pathname+=n,o.push(e)}if(r){const e=new URL(c);e.pathname+=".html",o.push(e)}if(s){const e=s({url:i});o=o.concat(e)}const l=v.getCachedUrls();for(const e of o)if(-1!==l.indexOf(e.href))return e.href;return null},R={precache:e=>{v.addToCacheList(e),f||e.length<=0||(f=!0,self.addEventListener("install",e=>{e.waitUntil(v.install({event:e,plugins:w,suppressWarnings:b}))}),self.addEventListener("activate",e=>{e.waitUntil(v.activate({event:e,plugins:w}))}))},addRoute:e=>{y||(y=!0,self.addEventListener("fetch",t=>{const n=m(t.request.url,e);if(!n)return;let r=caches.open(g).then(e=>e.match(n)).then(e=>e||fetch(n));t.respondWith(r)}))},precacheAndRoute:(e,t)=>{R.precache(e),R.addRoute(t)},suppressWarnings:e=>{b=e},addPlugins:e=>{w=w.concat(e)}};return Object.assign(R,p)}(workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private);

>>>>>>> 2cfd330b (move react to root dir)
//# sourceMappingURL=workbox-precaching.prod.js.map
