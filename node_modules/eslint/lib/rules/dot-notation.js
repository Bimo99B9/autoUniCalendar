/**
 * @fileoverview Rule to warn about using dot notation instead of square bracket notation when possible.
 * @author Josh Perez
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

<<<<<<< HEAD
const astUtils = require("./utils/ast-utils");
const keywords = require("./utils/keywords");
=======
const astUtils = require("../util/ast-utils");
>>>>>>> 2cfd330b (move react to root dir)

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

<<<<<<< HEAD
const validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/u;

// `null` literal must be handled separately.
const literalTypesToCheck = new Set(["string", "boolean"]);

/** @type {import('../shared/types').Rule} */
=======
const validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/;
const keywords = require("../util/keywords");

>>>>>>> 2cfd330b (move react to root dir)
module.exports = {
    meta: {
        type: "suggestion",

        docs: {
<<<<<<< HEAD
            description: "Enforce dot notation whenever possible",
=======
            description: "enforce dot notation whenever possible",
            category: "Best Practices",
>>>>>>> 2cfd330b (move react to root dir)
            recommended: false,
            url: "https://eslint.org/docs/rules/dot-notation"
        },

        schema: [
            {
                type: "object",
                properties: {
                    allowKeywords: {
<<<<<<< HEAD
                        type: "boolean",
                        default: true
                    },
                    allowPattern: {
                        type: "string",
                        default: ""
=======
                        type: "boolean"
                    },
                    allowPattern: {
                        type: "string"
>>>>>>> 2cfd330b (move react to root dir)
                    }
                },
                additionalProperties: false
            }
        ],

        fixable: "code",

        messages: {
            useDot: "[{{key}}] is better written in dot notation.",
            useBrackets: ".{{key}} is a syntax error."
        }
    },

    create(context) {
        const options = context.options[0] || {};
<<<<<<< HEAD
        const allowKeywords = options.allowKeywords === void 0 || options.allowKeywords;
=======
        const allowKeywords = options.allowKeywords === void 0 || !!options.allowKeywords;
>>>>>>> 2cfd330b (move react to root dir)
        const sourceCode = context.getSourceCode();

        let allowPattern;

        if (options.allowPattern) {
<<<<<<< HEAD
            allowPattern = new RegExp(options.allowPattern, "u");
=======
            allowPattern = new RegExp(options.allowPattern);
>>>>>>> 2cfd330b (move react to root dir)
        }

        /**
         * Check if the property is valid dot notation
         * @param {ASTNode} node The dot notation node
         * @param {string} value Value which is to be checked
         * @returns {void}
         */
        function checkComputedProperty(node, value) {
            if (
                validIdentifier.test(value) &&
<<<<<<< HEAD
                (allowKeywords || !keywords.includes(String(value))) &&
=======
                (allowKeywords || keywords.indexOf(String(value)) === -1) &&
>>>>>>> 2cfd330b (move react to root dir)
                !(allowPattern && allowPattern.test(value))
            ) {
                const formattedValue = node.property.type === "Literal" ? JSON.stringify(value) : `\`${value}\``;

                context.report({
                    node: node.property,
                    messageId: "useDot",
                    data: {
                        key: formattedValue
                    },
<<<<<<< HEAD
                    *fix(fixer) {
                        const leftBracket = sourceCode.getTokenAfter(node.object, astUtils.isOpeningBracketToken);
                        const rightBracket = sourceCode.getLastToken(node);
                        const nextToken = sourceCode.getTokenAfter(node);

                        // Don't perform any fixes if there are comments inside the brackets.
                        if (sourceCode.commentsExistBetween(leftBracket, rightBracket)) {
                            return;
                        }

                        // Replace the brackets by an identifier.
                        if (!node.optional) {
                            yield fixer.insertTextBefore(
                                leftBracket,
                                astUtils.isDecimalInteger(node.object) ? " ." : "."
                            );
                        }
                        yield fixer.replaceTextRange(
                            [leftBracket.range[0], rightBracket.range[1]],
                            value
                        );

                        // Insert a space after the property if it will be connected to the next token.
                        if (
                            nextToken &&
                            rightBracket.range[1] === nextToken.range[0] &&
                            !astUtils.canTokensBeAdjacent(String(value), nextToken)
                        ) {
                            yield fixer.insertTextAfter(node, " ");
                        }
=======
                    fix(fixer) {
                        const leftBracket = sourceCode.getTokenAfter(node.object, astUtils.isOpeningBracketToken);
                        const rightBracket = sourceCode.getLastToken(node);

                        if (sourceCode.getFirstTokenBetween(leftBracket, rightBracket, { includeComments: true, filter: astUtils.isCommentToken })) {

                            // Don't perform any fixes if there are comments inside the brackets.
                            return null;
                        }

                        const tokenAfterProperty = sourceCode.getTokenAfter(rightBracket);
                        const needsSpaceAfterProperty = tokenAfterProperty &&
                            rightBracket.range[1] === tokenAfterProperty.range[0] &&
                            !astUtils.canTokensBeAdjacent(String(value), tokenAfterProperty);

                        const textBeforeDot = astUtils.isDecimalInteger(node.object) ? " " : "";
                        const textAfterProperty = needsSpaceAfterProperty ? " " : "";

                        return fixer.replaceTextRange(
                            [leftBracket.range[0], rightBracket.range[1]],
                            `${textBeforeDot}.${value}${textAfterProperty}`
                        );
>>>>>>> 2cfd330b (move react to root dir)
                    }
                });
            }
        }

        return {
            MemberExpression(node) {
                if (
                    node.computed &&
<<<<<<< HEAD
                    node.property.type === "Literal" &&
                    (literalTypesToCheck.has(typeof node.property.value) || astUtils.isNullLiteral(node.property))
=======
                    node.property.type === "Literal"
>>>>>>> 2cfd330b (move react to root dir)
                ) {
                    checkComputedProperty(node, node.property.value);
                }
                if (
                    node.computed &&
                    node.property.type === "TemplateLiteral" &&
                    node.property.expressions.length === 0
                ) {
                    checkComputedProperty(node, node.property.quasis[0].value.cooked);
                }
                if (
                    !allowKeywords &&
                    !node.computed &&
<<<<<<< HEAD
                    node.property.type === "Identifier" &&
                    keywords.includes(String(node.property.name))
=======
                    keywords.indexOf(String(node.property.name)) !== -1
>>>>>>> 2cfd330b (move react to root dir)
                ) {
                    context.report({
                        node: node.property,
                        messageId: "useBrackets",
                        data: {
                            key: node.property.name
                        },
<<<<<<< HEAD
                        *fix(fixer) {
                            const dotToken = sourceCode.getTokenBefore(node.property);

                            // A statement that starts with `let[` is parsed as a destructuring variable declaration, not a MemberExpression.
                            if (node.object.type === "Identifier" && node.object.name === "let" && !node.optional) {
                                return;
                            }

                            // Don't perform any fixes if there are comments between the dot and the property name.
                            if (sourceCode.commentsExistBetween(dotToken, node.property)) {
                                return;
                            }

                            // Replace the identifier to brackets.
                            if (!node.optional) {
                                yield fixer.remove(dotToken);
                            }
                            yield fixer.replaceText(node.property, `["${node.property.name}"]`);
=======
                        fix(fixer) {
                            const dot = sourceCode.getTokenBefore(node.property);
                            const textAfterDot = sourceCode.text.slice(dot.range[1], node.property.range[0]);

                            if (textAfterDot.trim()) {

                                // Don't perform any fixes if there are comments between the dot and the property name.
                                return null;
                            }

                            if (node.object.type === "Identifier" && node.object.name === "let") {

                                /*
                                 * A statement that starts with `let[` is parsed as a destructuring variable declaration, not
                                 * a MemberExpression.
                                 */
                                return null;
                            }

                            return fixer.replaceTextRange(
                                [dot.range[0], node.property.range[1]],
                                `[${textAfterDot}"${node.property.name}"]`
                            );
>>>>>>> 2cfd330b (move react to root dir)
                        }
                    });
                }
            }
        };
    }
};
