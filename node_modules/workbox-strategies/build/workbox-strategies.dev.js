this.workbox = this.workbox || {};
<<<<<<< HEAD
this.workbox.strategies = (function (exports, assert_js, logger_js, WorkboxError_js, cacheNames_js, getFriendlyURL_js, cacheMatchIgnoreParams_js, Deferred_js, executeQuotaErrorCallbacks_js, timeout_js) {
    'use strict';

    try {
      self['workbox:strategies:6.5.3'] && _();
    } catch (e) {}

    /*
      Copyright 2020 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */

    function toRequest(input) {
      return typeof input === 'string' ? new Request(input) : input;
    }
    /**
     * A class created every time a Strategy instance instance calls
     * {@link workbox-strategies.Strategy~handle} or
     * {@link workbox-strategies.Strategy~handleAll} that wraps all fetch and
     * cache actions around plugin callbacks and keeps track of when the strategy
     * is "done" (i.e. all added `event.waitUntil()` promises have resolved).
     *
     * @memberof workbox-strategies
     */


    class StrategyHandler {
      /**
       * Creates a new instance associated with the passed strategy and event
       * that's handling the request.
       *
       * The constructor also initializes the state that will be passed to each of
       * the plugins handling this request.
       *
       * @param {workbox-strategies.Strategy} strategy
       * @param {Object} options
       * @param {Request|string} options.request A request to run this strategy for.
       * @param {ExtendableEvent} options.event The event associated with the
       *     request.
       * @param {URL} [options.url]
       * @param {*} [options.params] The return value from the
       *     {@link workbox-routing~matchCallback} (if applicable).
       */
      constructor(strategy, options) {
        this._cacheKeys = {};
        /**
         * The request the strategy is performing (passed to the strategy's
         * `handle()` or `handleAll()` method).
         * @name request
         * @instance
         * @type {Request}
         * @memberof workbox-strategies.StrategyHandler
         */

        /**
         * The event associated with this request.
         * @name event
         * @instance
         * @type {ExtendableEvent}
         * @memberof workbox-strategies.StrategyHandler
         */

        /**
         * A `URL` instance of `request.url` (if passed to the strategy's
         * `handle()` or `handleAll()` method).
         * Note: the `url` param will be present if the strategy was invoked
         * from a workbox `Route` object.
         * @name url
         * @instance
         * @type {URL|undefined}
         * @memberof workbox-strategies.StrategyHandler
         */

        /**
         * A `param` value (if passed to the strategy's
         * `handle()` or `handleAll()` method).
         * Note: the `param` param will be present if the strategy was invoked
         * from a workbox `Route` object and the
         * {@link workbox-routing~matchCallback} returned
         * a truthy value (it will be that value).
         * @name params
         * @instance
         * @type {*|undefined}
         * @memberof workbox-strategies.StrategyHandler
         */

        {
          assert_js.assert.isInstance(options.event, ExtendableEvent, {
            moduleName: 'workbox-strategies',
            className: 'StrategyHandler',
            funcName: 'constructor',
            paramName: 'options.event'
          });
        }

        Object.assign(this, options);
        this.event = options.event;
        this._strategy = strategy;
        this._handlerDeferred = new Deferred_js.Deferred();
        this._extendLifetimePromises = []; // Copy the plugins list (since it's mutable on the strategy),
        // so any mutations don't affect this handler instance.

        this._plugins = [...strategy.plugins];
        this._pluginStateMap = new Map();

        for (const plugin of this._plugins) {
          this._pluginStateMap.set(plugin, {});
        }

        this.event.waitUntil(this._handlerDeferred.promise);
      }
      /**
       * Fetches a given request (and invokes any applicable plugin callback
       * methods) using the `fetchOptions` (for non-navigation requests) and
       * `plugins` defined on the `Strategy` object.
       *
       * The following plugin lifecycle methods are invoked when using this method:
       * - `requestWillFetch()`
       * - `fetchDidSucceed()`
       * - `fetchDidFail()`
       *
       * @param {Request|string} input The URL or request to fetch.
       * @return {Promise<Response>}
       */


      async fetch(input) {
        const {
          event
        } = this;
        let request = toRequest(input);

        if (request.mode === 'navigate' && event instanceof FetchEvent && event.preloadResponse) {
          const possiblePreloadResponse = await event.preloadResponse;

          if (possiblePreloadResponse) {
            {
              logger_js.logger.log(`Using a preloaded navigation response for ` + `'${getFriendlyURL_js.getFriendlyURL(request.url)}'`);
            }

            return possiblePreloadResponse;
          }
        } // If there is a fetchDidFail plugin, we need to save a clone of the
        // original request before it's either modified by a requestWillFetch
        // plugin or before the original request's body is consumed via fetch().


        const originalRequest = this.hasCallback('fetchDidFail') ? request.clone() : null;

        try {
          for (const cb of this.iterateCallbacks('requestWillFetch')) {
            request = await cb({
              request: request.clone(),
              event
            });
          }
        } catch (err) {
          if (err instanceof Error) {
            throw new WorkboxError_js.WorkboxError('plugin-error-request-will-fetch', {
              thrownErrorMessage: err.message
            });
          }
        } // The request can be altered by plugins with `requestWillFetch` making
        // the original request (most likely from a `fetch` event) different
        // from the Request we make. Pass both to `fetchDidFail` to aid debugging.


        const pluginFilteredRequest = request.clone();

        try {
          let fetchResponse; // See https://github.com/GoogleChrome/workbox/issues/1796

          fetchResponse = await fetch(request, request.mode === 'navigate' ? undefined : this._strategy.fetchOptions);

          if ("dev" !== 'production') {
            logger_js.logger.debug(`Network request for ` + `'${getFriendlyURL_js.getFriendlyURL(request.url)}' returned a response with ` + `status '${fetchResponse.status}'.`);
          }

          for (const callback of this.iterateCallbacks('fetchDidSucceed')) {
            fetchResponse = await callback({
              event,
              request: pluginFilteredRequest,
              response: fetchResponse
            });
          }

          return fetchResponse;
        } catch (error) {
          {
            logger_js.logger.log(`Network request for ` + `'${getFriendlyURL_js.getFriendlyURL(request.url)}' threw an error.`, error);
          } // `originalRequest` will only exist if a `fetchDidFail` callback
          // is being used (see above).


          if (originalRequest) {
            await this.runCallbacks('fetchDidFail', {
              error: error,
              event,
              originalRequest: originalRequest.clone(),
              request: pluginFilteredRequest.clone()
            });
          }

          throw error;
        }
      }
      /**
       * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on
       * the response generated by `this.fetch()`.
       *
       * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,
       * so you do not have to manually call `waitUntil()` on the event.
       *
       * @param {Request|string} input The request or URL to fetch and cache.
       * @return {Promise<Response>}
       */


      async fetchAndCachePut(input) {
        const response = await this.fetch(input);
        const responseClone = response.clone();
        void this.waitUntil(this.cachePut(input, responseClone));
        return response;
      }
      /**
       * Matches a request from the cache (and invokes any applicable plugin
       * callback methods) using the `cacheName`, `matchOptions`, and `plugins`
       * defined on the strategy object.
       *
       * The following plugin lifecycle methods are invoked when using this method:
       * - cacheKeyWillByUsed()
       * - cachedResponseWillByUsed()
       *
       * @param {Request|string} key The Request or URL to use as the cache key.
       * @return {Promise<Response|undefined>} A matching response, if found.
       */


      async cacheMatch(key) {
        const request = toRequest(key);
        let cachedResponse;
        const {
          cacheName,
          matchOptions
        } = this._strategy;
        const effectiveRequest = await this.getCacheKey(request, 'read');
        const multiMatchOptions = Object.assign(Object.assign({}, matchOptions), {
          cacheName
        });
        cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);

        {
          if (cachedResponse) {
            logger_js.logger.debug(`Found a cached response in '${cacheName}'.`);
          } else {
            logger_js.logger.debug(`No cached response found in '${cacheName}'.`);
          }
        }

        for (const callback of this.iterateCallbacks('cachedResponseWillBeUsed')) {
          cachedResponse = (await callback({
            cacheName,
            matchOptions,
            cachedResponse,
            request: effectiveRequest,
            event: this.event
          })) || undefined;
        }

        return cachedResponse;
      }
      /**
       * Puts a request/response pair in the cache (and invokes any applicable
       * plugin callback methods) using the `cacheName` and `plugins` defined on
       * the strategy object.
       *
       * The following plugin lifecycle methods are invoked when using this method:
       * - cacheKeyWillByUsed()
       * - cacheWillUpdate()
       * - cacheDidUpdate()
       *
       * @param {Request|string} key The request or URL to use as the cache key.
       * @param {Response} response The response to cache.
       * @return {Promise<boolean>} `false` if a cacheWillUpdate caused the response
       * not be cached, and `true` otherwise.
       */


      async cachePut(key, response) {
        const request = toRequest(key); // Run in the next task to avoid blocking other cache reads.
        // https://github.com/w3c/ServiceWorker/issues/1397

        await timeout_js.timeout(0);
        const effectiveRequest = await this.getCacheKey(request, 'write');

        {
          if (effectiveRequest.method && effectiveRequest.method !== 'GET') {
            throw new WorkboxError_js.WorkboxError('attempt-to-cache-non-get-request', {
              url: getFriendlyURL_js.getFriendlyURL(effectiveRequest.url),
              method: effectiveRequest.method
            });
          } // See https://github.com/GoogleChrome/workbox/issues/2818


          const vary = response.headers.get('Vary');

          if (vary) {
            logger_js.logger.debug(`The response for ${getFriendlyURL_js.getFriendlyURL(effectiveRequest.url)} ` + `has a 'Vary: ${vary}' header. ` + `Consider setting the {ignoreVary: true} option on your strategy ` + `to ensure cache matching and deletion works as expected.`);
          }
        }

        if (!response) {
          {
            logger_js.logger.error(`Cannot cache non-existent response for ` + `'${getFriendlyURL_js.getFriendlyURL(effectiveRequest.url)}'.`);
          }

          throw new WorkboxError_js.WorkboxError('cache-put-with-no-response', {
            url: getFriendlyURL_js.getFriendlyURL(effectiveRequest.url)
          });
        }

        const responseToCache = await this._ensureResponseSafeToCache(response);

        if (!responseToCache) {
          {
            logger_js.logger.debug(`Response '${getFriendlyURL_js.getFriendlyURL(effectiveRequest.url)}' ` + `will not be cached.`, responseToCache);
          }

          return false;
        }

        const {
          cacheName,
          matchOptions
        } = this._strategy;
        const cache = await self.caches.open(cacheName);
        const hasCacheUpdateCallback = this.hasCallback('cacheDidUpdate');
        const oldResponse = hasCacheUpdateCallback ? await cacheMatchIgnoreParams_js.cacheMatchIgnoreParams( // TODO(philipwalton): the `__WB_REVISION__` param is a precaching
        // feature. Consider into ways to only add this behavior if using
        // precaching.
        cache, effectiveRequest.clone(), ['__WB_REVISION__'], matchOptions) : null;

        {
          logger_js.logger.debug(`Updating the '${cacheName}' cache with a new Response ` + `for ${getFriendlyURL_js.getFriendlyURL(effectiveRequest.url)}.`);
        }

        try {
          await cache.put(effectiveRequest, hasCacheUpdateCallback ? responseToCache.clone() : responseToCache);
        } catch (error) {
          if (error instanceof Error) {
            // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError
            if (error.name === 'QuotaExceededError') {
              await executeQuotaErrorCallbacks_js.executeQuotaErrorCallbacks();
            }

            throw error;
          }
        }

        for (const callback of this.iterateCallbacks('cacheDidUpdate')) {
          await callback({
            cacheName,
            oldResponse,
            newResponse: responseToCache.clone(),
            request: effectiveRequest,
            event: this.event
          });
        }

        return true;
      }
      /**
       * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and
       * executes any of those callbacks found in sequence. The final `Request`
       * object returned by the last plugin is treated as the cache key for cache
       * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have
       * been registered, the passed request is returned unmodified
       *
       * @param {Request} request
       * @param {string} mode
       * @return {Promise<Request>}
       */


      async getCacheKey(request, mode) {
        const key = `${request.url} | ${mode}`;

        if (!this._cacheKeys[key]) {
          let effectiveRequest = request;

          for (const callback of this.iterateCallbacks('cacheKeyWillBeUsed')) {
            effectiveRequest = toRequest(await callback({
              mode,
              request: effectiveRequest,
              event: this.event,
              // params has a type any can't change right now.
              params: this.params // eslint-disable-line

            }));
          }

          this._cacheKeys[key] = effectiveRequest;
        }

        return this._cacheKeys[key];
      }
      /**
       * Returns true if the strategy has at least one plugin with the given
       * callback.
       *
       * @param {string} name The name of the callback to check for.
       * @return {boolean}
       */


      hasCallback(name) {
        for (const plugin of this._strategy.plugins) {
          if (name in plugin) {
            return true;
          }
        }

        return false;
      }
      /**
       * Runs all plugin callbacks matching the given name, in order, passing the
       * given param object (merged ith the current plugin state) as the only
       * argument.
       *
       * Note: since this method runs all plugins, it's not suitable for cases
       * where the return value of a callback needs to be applied prior to calling
       * the next callback. See
       * {@link workbox-strategies.StrategyHandler#iterateCallbacks}
       * below for how to handle that case.
       *
       * @param {string} name The name of the callback to run within each plugin.
       * @param {Object} param The object to pass as the first (and only) param
       *     when executing each callback. This object will be merged with the
       *     current plugin state prior to callback execution.
       */


      async runCallbacks(name, param) {
        for (const callback of this.iterateCallbacks(name)) {
          // TODO(philipwalton): not sure why `any` is needed. It seems like
          // this should work with `as WorkboxPluginCallbackParam[C]`.
          await callback(param);
        }
      }
      /**
       * Accepts a callback and returns an iterable of matching plugin callbacks,
       * where each callback is wrapped with the current handler state (i.e. when
       * you call each callback, whatever object parameter you pass it will
       * be merged with the plugin's current state).
       *
       * @param {string} name The name fo the callback to run
       * @return {Array<Function>}
       */


      *iterateCallbacks(name) {
        for (const plugin of this._strategy.plugins) {
          if (typeof plugin[name] === 'function') {
            const state = this._pluginStateMap.get(plugin);

            const statefulCallback = param => {
              const statefulParam = Object.assign(Object.assign({}, param), {
                state
              }); // TODO(philipwalton): not sure why `any` is needed. It seems like
              // this should work with `as WorkboxPluginCallbackParam[C]`.

              return plugin[name](statefulParam);
            };

            yield statefulCallback;
          }
        }
      }
      /**
       * Adds a promise to the
       * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}
       * of the event event associated with the request being handled (usually a
       * `FetchEvent`).
       *
       * Note: you can await
       * {@link workbox-strategies.StrategyHandler~doneWaiting}
       * to know when all added promises have settled.
       *
       * @param {Promise} promise A promise to add to the extend lifetime promises
       *     of the event that triggered the request.
       */


      waitUntil(promise) {
        this._extendLifetimePromises.push(promise);

        return promise;
      }
      /**
       * Returns a promise that resolves once all promises passed to
       * {@link workbox-strategies.StrategyHandler~waitUntil}
       * have settled.
       *
       * Note: any work done after `doneWaiting()` settles should be manually
       * passed to an event's `waitUntil()` method (not this handler's
       * `waitUntil()` method), otherwise the service worker thread my be killed
       * prior to your work completing.
       */


      async doneWaiting() {
        let promise;

        while (promise = this._extendLifetimePromises.shift()) {
          await promise;
        }
      }
      /**
       * Stops running the strategy and immediately resolves any pending
       * `waitUntil()` promises.
       */


      destroy() {
        this._handlerDeferred.resolve(null);
      }
      /**
       * This method will call cacheWillUpdate on the available plugins (or use
       * status === 200) to determine if the Response is safe and valid to cache.
       *
       * @param {Request} options.request
       * @param {Response} options.response
       * @return {Promise<Response|undefined>}
       *
       * @private
       */


      async _ensureResponseSafeToCache(response) {
        let responseToCache = response;
        let pluginsUsed = false;

        for (const callback of this.iterateCallbacks('cacheWillUpdate')) {
          responseToCache = (await callback({
            request: this.request,
            response: responseToCache,
            event: this.event
          })) || undefined;
          pluginsUsed = true;

          if (!responseToCache) {
            break;
          }
        }

        if (!pluginsUsed) {
          if (responseToCache && responseToCache.status !== 200) {
            responseToCache = undefined;
          }

          {
            if (responseToCache) {
              if (responseToCache.status !== 200) {
                if (responseToCache.status === 0) {
                  logger_js.logger.warn(`The response for '${this.request.url}' ` + `is an opaque response. The caching strategy that you're ` + `using will not cache opaque responses by default.`);
                } else {
                  logger_js.logger.debug(`The response for '${this.request.url}' ` + `returned a status code of '${response.status}' and won't ` + `be cached as a result.`);
                }
              }
            }
          }
        }

        return responseToCache;
      }

    }

    /*
      Copyright 2020 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * An abstract base class that all other strategy classes must extend from:
     *
     * @memberof workbox-strategies
     */

    class Strategy {
      /**
       * Creates a new instance of the strategy and sets all documented option
       * properties as public instance properties.
       *
       * Note: if a custom strategy class extends the base Strategy class and does
       * not need more than these properties, it does not need to define its own
       * constructor.
       *
       * @param {Object} [options]
       * @param {string} [options.cacheName] Cache name to store and retrieve
       * requests. Defaults to the cache names provided by
       * {@link workbox-core.cacheNames}.
       * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
       * to use in conjunction with this caching strategy.
       * @param {Object} [options.fetchOptions] Values passed along to the
       * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)
       * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)
       * `fetch()` requests made by this strategy.
       * @param {Object} [options.matchOptions] The
       * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}
       * for any `cache.match()` or `cache.put()` calls made by this strategy.
       */
      constructor(options = {}) {
        /**
         * Cache name to store and retrieve
         * requests. Defaults to the cache names provided by
         * {@link workbox-core.cacheNames}.
         *
         * @type {string}
         */
        this.cacheName = cacheNames_js.cacheNames.getRuntimeName(options.cacheName);
        /**
         * The list
         * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
         * used by this strategy.
         *
         * @type {Array<Object>}
         */

        this.plugins = options.plugins || [];
        /**
         * Values passed along to the
         * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}
         * of all fetch() requests made by this strategy.
         *
         * @type {Object}
         */

        this.fetchOptions = options.fetchOptions;
        /**
         * The
         * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}
         * for any `cache.match()` or `cache.put()` calls made by this strategy.
         *
         * @type {Object}
         */

        this.matchOptions = options.matchOptions;
      }
      /**
       * Perform a request strategy and returns a `Promise` that will resolve with
       * a `Response`, invoking all relevant plugin callbacks.
       *
       * When a strategy instance is registered with a Workbox
       * {@link workbox-routing.Route}, this method is automatically
       * called when the route matches.
       *
       * Alternatively, this method can be used in a standalone `FetchEvent`
       * listener by passing it to `event.respondWith()`.
       *
       * @param {FetchEvent|Object} options A `FetchEvent` or an object with the
       *     properties listed below.
       * @param {Request|string} options.request A request to run this strategy for.
       * @param {ExtendableEvent} options.event The event associated with the
       *     request.
       * @param {URL} [options.url]
       * @param {*} [options.params]
       */


      handle(options) {
        const [responseDone] = this.handleAll(options);
        return responseDone;
      }
      /**
       * Similar to {@link workbox-strategies.Strategy~handle}, but
       * instead of just returning a `Promise` that resolves to a `Response` it
       * it will return an tuple of `[response, done]` promises, where the former
       * (`response`) is equivalent to what `handle()` returns, and the latter is a
       * Promise that will resolve once any promises that were added to
       * `event.waitUntil()` as part of performing the strategy have completed.
       *
       * You can await the `done` promise to ensure any extra work performed by
       * the strategy (usually caching responses) completes successfully.
       *
       * @param {FetchEvent|Object} options A `FetchEvent` or an object with the
       *     properties listed below.
       * @param {Request|string} options.request A request to run this strategy for.
       * @param {ExtendableEvent} options.event The event associated with the
       *     request.
       * @param {URL} [options.url]
       * @param {*} [options.params]
       * @return {Array<Promise>} A tuple of [response, done]
       *     promises that can be used to determine when the response resolves as
       *     well as when the handler has completed all its work.
       */


      handleAll(options) {
        // Allow for flexible options to be passed.
        if (options instanceof FetchEvent) {
          options = {
            event: options,
            request: options.request
          };
        }

        const event = options.event;
        const request = typeof options.request === 'string' ? new Request(options.request) : options.request;
        const params = 'params' in options ? options.params : undefined;
        const handler = new StrategyHandler(this, {
          event,
          request,
          params
        });

        const responseDone = this._getResponse(handler, request, event);

        const handlerDone = this._awaitComplete(responseDone, handler, request, event); // Return an array of promises, suitable for use with Promise.all().


        return [responseDone, handlerDone];
      }

      async _getResponse(handler, request, event) {
        await handler.runCallbacks('handlerWillStart', {
          event,
          request
        });
        let response = undefined;

        try {
          response = await this._handle(request, handler); // The "official" Strategy subclasses all throw this error automatically,
          // but in case a third-party Strategy doesn't, ensure that we have a
          // consistent failure when there's no response or an error response.

          if (!response || response.type === 'error') {
            throw new WorkboxError_js.WorkboxError('no-response', {
              url: request.url
            });
          }
        } catch (error) {
          if (error instanceof Error) {
            for (const callback of handler.iterateCallbacks('handlerDidError')) {
              response = await callback({
                error,
                event,
                request
              });

              if (response) {
                break;
              }
            }
          }

          if (!response) {
            throw error;
          } else {
            logger_js.logger.log(`While responding to '${getFriendlyURL_js.getFriendlyURL(request.url)}', ` + `an ${error instanceof Error ? error.toString() : ''} error occurred. Using a fallback response provided by ` + `a handlerDidError plugin.`);
          }
        }

        for (const callback of handler.iterateCallbacks('handlerWillRespond')) {
          response = await callback({
            event,
            request,
            response
          });
        }

        return response;
      }

      async _awaitComplete(responseDone, handler, request, event) {
        let response;
        let error;

        try {
          response = await responseDone;
        } catch (error) {// Ignore errors, as response errors should be caught via the `response`
          // promise above. The `done` promise will only throw for errors in
          // promises passed to `handler.waitUntil()`.
        }

        try {
          await handler.runCallbacks('handlerDidRespond', {
            event,
            request,
            response
          });
          await handler.doneWaiting();
        } catch (waitUntilError) {
          if (waitUntilError instanceof Error) {
            error = waitUntilError;
          }
        }

        await handler.runCallbacks('handlerDidComplete', {
          event,
          request,
          response,
          error: error
        });
        handler.destroy();

        if (error) {
          throw error;
        }
      }

    }
    /**
     * Classes extending the `Strategy` based class should implement this method,
     * and leverage the {@link workbox-strategies.StrategyHandler}
     * arg to perform all fetching and cache logic, which will ensure all relevant
     * cache, cache options, fetch options and plugins are used (per the current
     * strategy instance).
     *
     * @name _handle
     * @instance
     * @abstract
     * @function
     * @param {Request} request
     * @param {workbox-strategies.StrategyHandler} handler
     * @return {Promise<Response>}
     *
     * @memberof workbox-strategies.Strategy
     */

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    const messages = {
      strategyStart: (strategyName, request) => `Using ${strategyName} to respond to '${getFriendlyURL_js.getFriendlyURL(request.url)}'`,
      printFinalResponse: response => {
        if (response) {
          logger_js.logger.groupCollapsed(`View the final response here.`);
          logger_js.logger.log(response || '[No response returned]');
          logger_js.logger.groupEnd();
        }
      }
    };

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * An implementation of a [cache-first](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#cache-first-falling-back-to-network)
     * request strategy.
     *
     * A cache first strategy is useful for assets that have been revisioned,
     * such as URLs like `/styles/example.a8f5f1.css`, since they
     * can be cached for long periods of time.
     *
     * If the network request fails, and there is no cache match, this will throw
     * a `WorkboxError` exception.
     *
     * @extends workbox-strategies.Strategy
     * @memberof workbox-strategies
     */

    class CacheFirst extends Strategy {
      /**
       * @private
       * @param {Request|string} request A request to run this strategy for.
       * @param {workbox-strategies.StrategyHandler} handler The event that
       *     triggered the request.
       * @return {Promise<Response>}
       */
      async _handle(request, handler) {
        const logs = [];

        {
          assert_js.assert.isInstance(request, Request, {
            moduleName: 'workbox-strategies',
            className: this.constructor.name,
=======
this.workbox.strategies = (function (logger_mjs,assert_mjs,cacheNames_mjs,cacheWrapper_mjs,fetchWrapper_mjs,getFriendlyURL_mjs) {
  'use strict';

  try {
    self.workbox.v['workbox:strategies:3.6.3'] = 1;
  } catch (e) {} // eslint-disable-line

  /*
   Copyright 2018 Google Inc. All Rights Reserved.
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
  */

  const getFriendlyURL = url => {
    const urlObj = new URL(url, location);
    if (urlObj.origin === location.origin) {
      return urlObj.pathname;
    }
    return urlObj.href;
  };

  var messages = {
    strategyStart: (strategyName, request) => `Using ${strategyName} to ` + `respond to '${getFriendlyURL(request.url)}'`,
    printFinalResponse: response => {
      if (response) {
        logger_mjs.logger.groupCollapsed(`View the final response here.`);
        logger_mjs.logger.unprefixed.log(response);
        logger_mjs.logger.groupEnd();
      }
    }
  };

  /*
   Copyright 2018 Google Inc. All Rights Reserved.
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
  */

  /**
   * An implementation of a [cache-first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network}
   * request strategy.
   *
   * A cache first strategy is useful for assets that have been revisioned,
   * such as URLs like `/styles/example.a8f5f1.css`, since they
   * can be cached for long periods of time.
   *
   * @memberof workbox.strategies
   */
  class CacheFirst {
    /**
     * @param {Object} options
     * @param {string} options.cacheName Cache name to store and retrieve
     * requests. Defaults to cache names provided by
     * [workbox-core]{@link workbox.core.cacheNames}.
     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
     * to use in conjunction with this caching strategy.
     * @param {Object} options.fetchOptions Values passed along to the
     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)
     * of all fetch() requests made by this strategy.
     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)
     */
    constructor(options = {}) {
      this._cacheName = cacheNames_mjs.cacheNames.getRuntimeName(options.cacheName);
      this._plugins = options.plugins || [];
      this._fetchOptions = options.fetchOptions || null;
      this._matchOptions = options.matchOptions || null;
    }

    /**
     * This method will perform a request strategy and follows an API that
     * will work with the
     * [Workbox Router]{@link workbox.routing.Router}.
     *
     * @param {Object} options
     * @param {FetchEvent} options.event The fetch event to run this strategy
     * against.
     * @return {Promise<Response>}
     */
    handle({ event }) {
      var _this = this;

      return babelHelpers.asyncToGenerator(function* () {
        {
          assert_mjs.assert.isInstance(event, FetchEvent, {
            moduleName: 'workbox-strategies',
            className: 'CacheFirst',
            funcName: 'handle',
            paramName: 'event'
          });
        }

        return _this.makeRequest({
          event,
          request: event.request
        });
      })();
    }

    /**
     * This method can be used to perform a make a standalone request outside the
     * context of the [Workbox Router]{@link workbox.routing.Router}.
     *
     * See "[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)"
     * for more usage information.
     *
     * @param {Object} options
     * @param {Request|string} options.request Either a
     *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}
     *     object, or a string URL, corresponding to the request to be made.
     * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will
           be called automatically to extend the service worker's lifetime.
     * @return {Promise<Response>}
     */
    makeRequest({ event, request }) {
      var _this2 = this;

      return babelHelpers.asyncToGenerator(function* () {
        const logs = [];

        if (typeof request === 'string') {
          request = new Request(request);
        }

        {
          assert_mjs.assert.isInstance(request, Request, {
            moduleName: 'workbox-strategies',
            className: 'CacheFirst',
>>>>>>> 2cfd330b (move react to root dir)
            funcName: 'makeRequest',
            paramName: 'request'
          });
        }

<<<<<<< HEAD
        let response = await handler.cacheMatch(request);
        let error = undefined;

        if (!response) {
          {
            logs.push(`No response found in the '${this.cacheName}' cache. ` + `Will respond with a network request.`);
          }

          try {
            response = await handler.fetchAndCachePut(request);
          } catch (err) {
            if (err instanceof Error) {
              error = err;
            }
=======
        let response = yield cacheWrapper_mjs.cacheWrapper.match({
          cacheName: _this2._cacheName,
          request,
          event,
          matchOptions: _this2._matchOptions,
          plugins: _this2._plugins
        });

        let error;
        if (!response) {
          {
            logs.push(`No response found in the '${_this2._cacheName}' cache. ` + `Will respond with a network request.`);
          }
          try {
            response = yield _this2._getFromNetwork(request, event);
          } catch (err) {
            error = err;
>>>>>>> 2cfd330b (move react to root dir)
          }

          {
            if (response) {
              logs.push(`Got response from network.`);
            } else {
              logs.push(`Unable to get a response from the network.`);
            }
          }
        } else {
          {
<<<<<<< HEAD
            logs.push(`Found a cached response in the '${this.cacheName}' cache.`);
=======
            logs.push(`Found a cached response in the '${_this2._cacheName}' cache.`);
>>>>>>> 2cfd330b (move react to root dir)
          }
        }

        {
<<<<<<< HEAD
          logger_js.logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));

          for (const log of logs) {
            logger_js.logger.log(log);
          }

          messages.printFinalResponse(response);
          logger_js.logger.groupEnd();
        }

        if (!response) {
          throw new WorkboxError_js.WorkboxError('no-response', {
            url: request.url,
            error
          });
        }

        return response;
      }

    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * An implementation of a [cache-only](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#cache-only)
     * request strategy.
     *
     * This class is useful if you want to take advantage of any
     * [Workbox plugins](https://developer.chrome.com/docs/workbox/using-plugins/).
     *
     * If there is no cache match, this will throw a `WorkboxError` exception.
     *
     * @extends workbox-strategies.Strategy
     * @memberof workbox-strategies
     */

    class CacheOnly extends Strategy {
      /**
       * @private
       * @param {Request|string} request A request to run this strategy for.
       * @param {workbox-strategies.StrategyHandler} handler The event that
       *     triggered the request.
       * @return {Promise<Response>}
       */
      async _handle(request, handler) {
        {
          assert_js.assert.isInstance(request, Request, {
            moduleName: 'workbox-strategies',
            className: this.constructor.name,
=======
          logger_mjs.logger.groupCollapsed(messages.strategyStart('CacheFirst', request));
          for (let log of logs) {
            logger_mjs.logger.log(log);
          }
          messages.printFinalResponse(response);
          logger_mjs.logger.groupEnd();
        }

        if (error) {
          // Don't swallow error as we'll want it to throw and enable catch
          // handlers in router.
          throw error;
        }

        return response;
      })();
    }

    /**
     * Handles the network and cache part of CacheFirst.
     *
     * @param {Request} request
     * @param {FetchEvent} [event]
     * @return {Promise<Response>}
     *
     * @private
     */
    _getFromNetwork(request, event) {
      var _this3 = this;

      return babelHelpers.asyncToGenerator(function* () {
        const response = yield fetchWrapper_mjs.fetchWrapper.fetch({
          request,
          event,
          fetchOptions: _this3._fetchOptions,
          plugins: _this3._plugins
        });

        // Keep the service worker while we put the request to the cache
        const responseClone = response.clone();
        const cachePutPromise = cacheWrapper_mjs.cacheWrapper.put({
          cacheName: _this3._cacheName,
          request,
          response: responseClone,
          event,
          plugins: _this3._plugins
        });

        if (event) {
          try {
            event.waitUntil(cachePutPromise);
          } catch (error) {
            {
              logger_mjs.logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache for '${getFriendlyURL_mjs.getFriendlyURL(event.request.url)}'.`);
            }
          }
        }

        return response;
      })();
    }
  }

  /*
   Copyright 2018 Google Inc. All Rights Reserved.
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
  */

  /**
   * An implementation of a
   * [cache-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-only}
   * request strategy.
   *
   * This class is useful if you want to take advantage of any [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.
   *
   * @memberof workbox.strategies
   */
  class CacheOnly {
    /**
     * @param {Object} options
     * @param {string} options.cacheName Cache name to store and retrieve
     * requests. Defaults to cache names provided by
     * [workbox-core]{@link workbox.core.cacheNames}.
     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
     * to use in conjunction with this caching strategy.
     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)
     */
    constructor(options = {}) {
      this._cacheName = cacheNames_mjs.cacheNames.getRuntimeName(options.cacheName);
      this._plugins = options.plugins || [];
      this._matchOptions = options.matchOptions || null;
    }

    /**
     * This method will perform a request strategy and follows an API that
     * will work with the
     * [Workbox Router]{@link workbox.routing.Router}.
     *
     * @param {Object} options
     * @param {FetchEvent} options.event The fetch event to run this strategy
     * against.
     * @return {Promise<Response>}
     */
    handle({ event }) {
      var _this = this;

      return babelHelpers.asyncToGenerator(function* () {
        {
          assert_mjs.assert.isInstance(event, FetchEvent, {
            moduleName: 'workbox-strategies',
            className: 'CacheOnly',
            funcName: 'handle',
            paramName: 'event'
          });
        }

        return _this.makeRequest({
          event,
          request: event.request
        });
      })();
    }

    /**
     * This method can be used to perform a make a standalone request outside the
     * context of the [Workbox Router]{@link workbox.routing.Router}.
     *
     * See "[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)"
     * for more usage information.
     *
     * @param {Object} options
     * @param {Request|string} options.request Either a
     *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}
     *     object, or a string URL, corresponding to the request to be made.
     * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will
     *     be called automatically to extend the service worker's lifetime.
     * @return {Promise<Response>}
     */
    makeRequest({ event, request }) {
      var _this2 = this;

      return babelHelpers.asyncToGenerator(function* () {
        if (typeof request === 'string') {
          request = new Request(request);
        }

        {
          assert_mjs.assert.isInstance(request, Request, {
            moduleName: 'workbox-strategies',
            className: 'CacheOnly',
>>>>>>> 2cfd330b (move react to root dir)
            funcName: 'makeRequest',
            paramName: 'request'
          });
        }

<<<<<<< HEAD
        const response = await handler.cacheMatch(request);

        {
          logger_js.logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));

          if (response) {
            logger_js.logger.log(`Found a cached response in the '${this.cacheName}' ` + `cache.`);
            messages.printFinalResponse(response);
          } else {
            logger_js.logger.log(`No response found in the '${this.cacheName}' cache.`);
          }

          logger_js.logger.groupEnd();
        }

        if (!response) {
          throw new WorkboxError_js.WorkboxError('no-response', {
            url: request.url
          });
        }

        return response;
      }

    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    const cacheOkAndOpaquePlugin = {
      /**
       * Returns a valid response (to allow caching) if the status is 200 (OK) or
       * 0 (opaque).
       *
       * @param {Object} options
       * @param {Response} options.response
       * @return {Response|null}
       *
       * @private
       */
      cacheWillUpdate: async ({
        response
      }) => {
        if (response.status === 200 || response.status === 0) {
          return response;
        }

        return null;
      }
    };

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * An implementation of a
     * [network first](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#network-first-falling-back-to-cache)
     * request strategy.
     *
     * By default, this strategy will cache responses with a 200 status code as
     * well as [opaque responses](https://developer.chrome.com/docs/workbox/caching-resources-during-runtime/#opaque-responses).
     * Opaque responses are are cross-origin requests where the response doesn't
     * support [CORS](https://enable-cors.org/).
     *
     * If the network request fails, and there is no cache match, this will throw
     * a `WorkboxError` exception.
     *
     * @extends workbox-strategies.Strategy
     * @memberof workbox-strategies
     */

    class NetworkFirst extends Strategy {
      /**
       * @param {Object} [options]
       * @param {string} [options.cacheName] Cache name to store and retrieve
       * requests. Defaults to cache names provided by
       * {@link workbox-core.cacheNames}.
       * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
       * to use in conjunction with this caching strategy.
       * @param {Object} [options.fetchOptions] Values passed along to the
       * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)
       * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)
       * `fetch()` requests made by this strategy.
       * @param {Object} [options.matchOptions] [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)
       * @param {number} [options.networkTimeoutSeconds] If set, any network requests
       * that fail to respond within the timeout will fallback to the cache.
       *
       * This option can be used to combat
       * "[lie-fi]{@link https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi}"
       * scenarios.
       */
      constructor(options = {}) {
        super(options); // If this instance contains no plugins with a 'cacheWillUpdate' callback,
        // prepend the `cacheOkAndOpaquePlugin` plugin to the plugins list.

        if (!this.plugins.some(p => 'cacheWillUpdate' in p)) {
          this.plugins.unshift(cacheOkAndOpaquePlugin);
        }

        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;

        {
          if (this._networkTimeoutSeconds) {
            assert_js.assert.isType(this._networkTimeoutSeconds, 'number', {
              moduleName: 'workbox-strategies',
              className: this.constructor.name,
              funcName: 'constructor',
              paramName: 'networkTimeoutSeconds'
            });
          }
        }
      }
      /**
       * @private
       * @param {Request|string} request A request to run this strategy for.
       * @param {workbox-strategies.StrategyHandler} handler The event that
       *     triggered the request.
       * @return {Promise<Response>}
       */


      async _handle(request, handler) {
        const logs = [];

        {
          assert_js.assert.isInstance(request, Request, {
            moduleName: 'workbox-strategies',
            className: this.constructor.name,
=======
        const response = yield cacheWrapper_mjs.cacheWrapper.match({
          cacheName: _this2._cacheName,
          request,
          event,
          matchOptions: _this2._matchOptions,
          plugins: _this2._plugins
        });

        {
          logger_mjs.logger.groupCollapsed(messages.strategyStart('CacheOnly', request));
          if (response) {
            logger_mjs.logger.log(`Found a cached response in the '${_this2._cacheName}'` + ` cache.`);
            messages.printFinalResponse(response);
          } else {
            logger_mjs.logger.log(`No response found in the '${_this2._cacheName}' cache.`);
          }
          logger_mjs.logger.groupEnd();
        }

        return response;
      })();
    }
  }

  /*
   Copyright 2016 Google Inc. All Rights Reserved.
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
  */

  var cacheOkAndOpaquePlugin = {
    /**
     * Return return a response (i.e. allow caching) if the
     * response is ok (i.e. 200) or is opaque.
     *
     * @param {Object} options
     * @param {Response} options.response
     * @return {Response|null}
     *
     * @private
     */
    cacheWillUpdate: ({ response }) => {
      if (response.ok || response.status === 0) {
        return response;
      }
      return null;
    }
  };

  /*
   Copyright 2018 Google Inc. All Rights Reserved.
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
  */

  /**
   * An implementation of a
   * [network first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-falling-back-to-cache}
   * request strategy.
   *
   * By default, this strategy will cache responses with a 200 status code as
   * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.
   * Opaque responses are are cross-origin requests where the response doesn't
   * support [CORS]{@link https://enable-cors.org/}.
   *
   * @memberof workbox.strategies
   */
  class NetworkFirst {
    /**
     * @param {Object} options
     * @param {string} options.cacheName Cache name to store and retrieve
     * requests. Defaults to cache names provided by
     * [workbox-core]{@link workbox.core.cacheNames}.
     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
     * to use in conjunction with this caching strategy.
     * @param {Object} options.fetchOptions Values passed along to the
     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)
     * of all fetch() requests made by this strategy.
     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)
     * @param {number} options.networkTimeoutSeconds If set, any network requests
     * that fail to respond within the timeout will fallback to the cache.
     *
     * This option can be used to combat
     * "[lie-fi]{@link https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi}"
     * scenarios.
     */
    constructor(options = {}) {
      this._cacheName = cacheNames_mjs.cacheNames.getRuntimeName(options.cacheName);

      if (options.plugins) {
        let isUsingCacheWillUpdate = options.plugins.some(plugin => !!plugin.cacheWillUpdate);
        this._plugins = isUsingCacheWillUpdate ? options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];
      } else {
        // No plugins passed in, use the default plugin.
        this._plugins = [cacheOkAndOpaquePlugin];
      }

      this._networkTimeoutSeconds = options.networkTimeoutSeconds;
      {
        if (this._networkTimeoutSeconds) {
          assert_mjs.assert.isType(this._networkTimeoutSeconds, 'number', {
            moduleName: 'workbox-strategies',
            className: 'NetworkFirst',
            funcName: 'constructor',
            paramName: 'networkTimeoutSeconds'
          });
        }
      }

      this._fetchOptions = options.fetchOptions || null;
      this._matchOptions = options.matchOptions || null;
    }

    /**
     * This method will perform a request strategy and follows an API that
     * will work with the
     * [Workbox Router]{@link workbox.routing.Router}.
     *
     * @param {Object} options
     * @param {FetchEvent} options.event The fetch event to run this strategy
     * against.
     * @return {Promise<Response>}
     */
    handle({ event }) {
      var _this = this;

      return babelHelpers.asyncToGenerator(function* () {
        {
          assert_mjs.assert.isInstance(event, FetchEvent, {
            moduleName: 'workbox-strategies',
            className: 'NetworkFirst',
            funcName: 'handle',
            paramName: 'event'
          });
        }

        return _this.makeRequest({
          event,
          request: event.request
        });
      })();
    }

    /**
     * This method can be used to perform a make a standalone request outside the
     * context of the [Workbox Router]{@link workbox.routing.Router}.
     *
     * See "[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)"
     * for more usage information.
     *
     * @param {Object} options
     * @param {Request|string} options.request Either a
     *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}
     *     object, or a string URL, corresponding to the request to be made.
     * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will
     *     be called automatically to extend the service worker's lifetime.
     * @return {Promise<Response>}
     */
    makeRequest({ event, request }) {
      var _this2 = this;

      return babelHelpers.asyncToGenerator(function* () {
        const logs = [];

        if (typeof request === 'string') {
          request = new Request(request);
        }

        {
          assert_mjs.assert.isInstance(request, Request, {
            moduleName: 'workbox-strategies',
            className: 'NetworkFirst',
>>>>>>> 2cfd330b (move react to root dir)
            funcName: 'handle',
            paramName: 'makeRequest'
          });
        }

        const promises = [];
        let timeoutId;

<<<<<<< HEAD
        if (this._networkTimeoutSeconds) {
          const {
            id,
            promise
          } = this._getTimeoutPromise({
            request,
            logs,
            handler
          });

=======
        if (_this2._networkTimeoutSeconds) {
          const { id, promise } = _this2._getTimeoutPromise({ request, event, logs });
>>>>>>> 2cfd330b (move react to root dir)
          timeoutId = id;
          promises.push(promise);
        }

<<<<<<< HEAD
        const networkPromise = this._getNetworkPromise({
          timeoutId,
          request,
          logs,
          handler
        });

        promises.push(networkPromise);
        const response = await handler.waitUntil((async () => {
          // Promise.race() will resolve as soon as the first promise resolves.
          return (await handler.waitUntil(Promise.race(promises))) || ( // If Promise.race() resolved with null, it might be due to a network
          // timeout + a cache miss. If that were to happen, we'd rather wait until
          // the networkPromise resolves instead of returning null.
          // Note that it's fine to await an already-resolved promise, so we don't
          // have to check to see if it's still "in flight".
          await networkPromise);
        })());

        {
          logger_js.logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));

          for (const log of logs) {
            logger_js.logger.log(log);
          }

          messages.printFinalResponse(response);
          logger_js.logger.groupEnd();
        }

        if (!response) {
          throw new WorkboxError_js.WorkboxError('no-response', {
            url: request.url
          });
        }

        return response;
      }
      /**
       * @param {Object} options
       * @param {Request} options.request
       * @param {Array} options.logs A reference to the logs array
       * @param {Event} options.event
       * @return {Promise<Response>}
       *
       * @private
       */


      _getTimeoutPromise({
        request,
        logs,
        handler
      }) {
        let timeoutId;
        const timeoutPromise = new Promise(resolve => {
          const onNetworkTimeout = async () => {
            {
              logs.push(`Timing out the network response at ` + `${this._networkTimeoutSeconds} seconds.`);
            }

            resolve(await handler.cacheMatch(request));
          };

          timeoutId = setTimeout(onNetworkTimeout, this._networkTimeoutSeconds * 1000);
        });
        return {
          promise: timeoutPromise,
          id: timeoutId
        };
      }
      /**
       * @param {Object} options
       * @param {number|undefined} options.timeoutId
       * @param {Request} options.request
       * @param {Array} options.logs A reference to the logs Array.
       * @param {Event} options.event
       * @return {Promise<Response>}
       *
       * @private
       */


      async _getNetworkPromise({
        timeoutId,
        request,
        logs,
        handler
      }) {
        let error;
        let response;

        try {
          response = await handler.fetchAndCachePut(request);
        } catch (fetchError) {
          if (fetchError instanceof Error) {
            error = fetchError;
          }
=======
        const networkPromise = _this2._getNetworkPromise({ timeoutId, request, event, logs });
        promises.push(networkPromise);

        // Promise.race() will resolve as soon as the first promise resolves.
        let response = yield Promise.race(promises);
        // If Promise.race() resolved with null, it might be due to a network
        // timeout + a cache miss. If that were to happen, we'd rather wait until
        // the networkPromise resolves instead of returning null.
        // Note that it's fine to await an already-resolved promise, so we don't
        // have to check to see if it's still "in flight".
        if (!response) {
          response = yield networkPromise;
        }

        {
          logger_mjs.logger.groupCollapsed(messages.strategyStart('NetworkFirst', request));
          for (let log of logs) {
            logger_mjs.logger.log(log);
          }
          messages.printFinalResponse(response);
          logger_mjs.logger.groupEnd();
        }

        return response;
      })();
    }

    /**
     * @param {Object} options
     * @param {Request} options.request
     * @param {Array} options.logs A reference to the logs array
     * @param {Event} [options.event]
     * @return {Promise<Response>}
     *
     * @private
     */
    _getTimeoutPromise({ request, logs, event }) {
      var _this3 = this;

      let timeoutId;
      const timeoutPromise = new Promise(resolve => {
        const onNetworkTimeout = (() => {
          var _ref = babelHelpers.asyncToGenerator(function* () {
            {
              logs.push(`Timing out the network response at ` + `${_this3._networkTimeoutSeconds} seconds.`);
            }

            resolve((yield _this3._respondFromCache({ request, event })));
          });

          return function onNetworkTimeout() {
            return _ref.apply(this, arguments);
          };
        })();

        timeoutId = setTimeout(onNetworkTimeout, this._networkTimeoutSeconds * 1000);
      });

      return {
        promise: timeoutPromise,
        id: timeoutId
      };
    }

    /**
     * @param {Object} options
     * @param {number|undefined} options.timeoutId
     * @param {Request} options.request
     * @param {Array} options.logs A reference to the logs Array.
     * @param {Event} [options.event]
     * @return {Promise<Response>}
     *
     * @private
     */
    _getNetworkPromise({ timeoutId, request, logs, event }) {
      var _this4 = this;

      return babelHelpers.asyncToGenerator(function* () {
        let error;
        let response;
        try {
          response = yield fetchWrapper_mjs.fetchWrapper.fetch({
            request,
            event,
            fetchOptions: _this4._fetchOptions,
            plugins: _this4._plugins
          });
        } catch (err) {
          error = err;
>>>>>>> 2cfd330b (move react to root dir)
        }

        if (timeoutId) {
          clearTimeout(timeoutId);
        }

        {
          if (response) {
            logs.push(`Got response from network.`);
          } else {
            logs.push(`Unable to get a response from the network. Will respond ` + `with a cached response.`);
          }
        }

        if (error || !response) {
<<<<<<< HEAD
          response = await handler.cacheMatch(request);

          {
            if (response) {
              logs.push(`Found a cached response in the '${this.cacheName}'` + ` cache.`);
            } else {
              logs.push(`No response found in the '${this.cacheName}' cache.`);
=======
          response = yield _this4._respondFromCache({ request, event });
          {
            if (response) {
              logs.push(`Found a cached response in the '${_this4._cacheName}'` + ` cache.`);
            } else {
              logs.push(`No response found in the '${_this4._cacheName}' cache.`);
            }
          }
        } else {
          // Keep the service worker alive while we put the request in the cache
          const responseClone = response.clone();
          const cachePut = cacheWrapper_mjs.cacheWrapper.put({
            cacheName: _this4._cacheName,
            request,
            response: responseClone,
            event,
            plugins: _this4._plugins
          });

          if (event) {
            try {
              // The event has been responded to so we can keep the SW alive to
              // respond to the request
              event.waitUntil(cachePut);
            } catch (err) {
              {
                logger_mjs.logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache for '${getFriendlyURL_mjs.getFriendlyURL(event.request.url)}'.`);
              }
>>>>>>> 2cfd330b (move react to root dir)
            }
          }
        }

        return response;
<<<<<<< HEAD
      }

    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * An implementation of a
     * [network-only](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#network-only)
     * request strategy.
     *
     * This class is useful if you want to take advantage of any
     * [Workbox plugins](https://developer.chrome.com/docs/workbox/using-plugins/).
     *
     * If the network request fails, this will throw a `WorkboxError` exception.
     *
     * @extends workbox-strategies.Strategy
     * @memberof workbox-strategies
     */

    class NetworkOnly extends Strategy {
      /**
       * @param {Object} [options]
       * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
       * to use in conjunction with this caching strategy.
       * @param {Object} [options.fetchOptions] Values passed along to the
       * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)
       * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)
       * `fetch()` requests made by this strategy.
       * @param {number} [options.networkTimeoutSeconds] If set, any network requests
       * that fail to respond within the timeout will result in a network error.
       */
      constructor(options = {}) {
        super(options);
        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;
      }
      /**
       * @private
       * @param {Request|string} request A request to run this strategy for.
       * @param {workbox-strategies.StrategyHandler} handler The event that
       *     triggered the request.
       * @return {Promise<Response>}
       */


      async _handle(request, handler) {
        {
          assert_js.assert.isInstance(request, Request, {
            moduleName: 'workbox-strategies',
            className: this.constructor.name,
            funcName: '_handle',
            paramName: 'request'
          });
        }

        let error = undefined;
        let response;

        try {
          const promises = [handler.fetch(request)];

          if (this._networkTimeoutSeconds) {
            const timeoutPromise = timeout_js.timeout(this._networkTimeoutSeconds * 1000);
            promises.push(timeoutPromise);
          }

          response = await Promise.race(promises);

          if (!response) {
            throw new Error(`Timed out the network response after ` + `${this._networkTimeoutSeconds} seconds.`);
          }
        } catch (err) {
          if (err instanceof Error) {
            error = err;
          }
        }

        {
          logger_js.logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));

          if (response) {
            logger_js.logger.log(`Got response from network.`);
          } else {
            logger_js.logger.log(`Unable to get a response from the network.`);
          }

          messages.printFinalResponse(response);
          logger_js.logger.groupEnd();
        }

        if (!response) {
          throw new WorkboxError_js.WorkboxError('no-response', {
            url: request.url,
            error
          });
        }

        return response;
      }

    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * An implementation of a
     * [stale-while-revalidate](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#stale-while-revalidate)
     * request strategy.
     *
     * Resources are requested from both the cache and the network in parallel.
     * The strategy will respond with the cached version if available, otherwise
     * wait for the network response. The cache is updated with the network response
     * with each successful request.
     *
     * By default, this strategy will cache responses with a 200 status code as
     * well as [opaque responses](https://developer.chrome.com/docs/workbox/caching-resources-during-runtime/#opaque-responses).
     * Opaque responses are cross-origin requests where the response doesn't
     * support [CORS](https://enable-cors.org/).
     *
     * If the network request fails, and there is no cache match, this will throw
     * a `WorkboxError` exception.
     *
     * @extends workbox-strategies.Strategy
     * @memberof workbox-strategies
     */

    class StaleWhileRevalidate extends Strategy {
      /**
       * @param {Object} [options]
       * @param {string} [options.cacheName] Cache name to store and retrieve
       * requests. Defaults to cache names provided by
       * {@link workbox-core.cacheNames}.
       * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
       * to use in conjunction with this caching strategy.
       * @param {Object} [options.fetchOptions] Values passed along to the
       * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)
       * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)
       * `fetch()` requests made by this strategy.
       * @param {Object} [options.matchOptions] [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)
       */
      constructor(options = {}) {
        super(options); // If this instance contains no plugins with a 'cacheWillUpdate' callback,
        // prepend the `cacheOkAndOpaquePlugin` plugin to the plugins list.

        if (!this.plugins.some(p => 'cacheWillUpdate' in p)) {
          this.plugins.unshift(cacheOkAndOpaquePlugin);
        }
      }
      /**
       * @private
       * @param {Request|string} request A request to run this strategy for.
       * @param {workbox-strategies.StrategyHandler} handler The event that
       *     triggered the request.
       * @return {Promise<Response>}
       */


      async _handle(request, handler) {
        const logs = [];

        {
          assert_js.assert.isInstance(request, Request, {
            moduleName: 'workbox-strategies',
            className: this.constructor.name,
=======
      })();
    }

    /**
     * Used if the network timeouts or fails to make the request.
     *
     * @param {Object} options
     * @param {Request} request The request to match in the cache
     * @param {Event} [options.event]
     * @return {Promise<Object>}
     *
     * @private
     */
    _respondFromCache({ event, request }) {
      return cacheWrapper_mjs.cacheWrapper.match({
        cacheName: this._cacheName,
        request,
        event,
        matchOptions: this._matchOptions,
        plugins: this._plugins
      });
    }
  }

  /*
   Copyright 2018 Google Inc. All Rights Reserved.
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
  */

  /**
   * An implementation of a
   * [network-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-only}
   * request strategy.
   *
   * This class is useful if you want to take advantage of any [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.
   *
   * @memberof workbox.strategies
   */
  class NetworkOnly {
    /**
     * @param {Object} options
     * @param {string} options.cacheName Cache name to store and retrieve
     * requests. Defaults to cache names provided by
     * [workbox-core]{@link workbox.core.cacheNames}.
     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
     * to use in conjunction with this caching strategy.
     * @param {Object} options.fetchOptions Values passed along to the
     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)
     * of all fetch() requests made by this strategy.
     */
    constructor(options = {}) {
      this._cacheName = cacheNames_mjs.cacheNames.getRuntimeName(options.cacheName);
      this._plugins = options.plugins || [];
      this._fetchOptions = options.fetchOptions || null;
    }

    /**
     * This method will perform a request strategy and follows an API that
     * will work with the
     * [Workbox Router]{@link workbox.routing.Router}.
     *
     * @param {Object} options
     * @param {FetchEvent} options.event The fetch event to run this strategy
     * against.
     * @return {Promise<Response>}
     */
    handle({ event }) {
      var _this = this;

      return babelHelpers.asyncToGenerator(function* () {
        {
          assert_mjs.assert.isInstance(event, FetchEvent, {
            moduleName: 'workbox-strategies',
            className: 'NetworkOnly',
            funcName: 'handle',
            paramName: 'event'
          });
        }

        return _this.makeRequest({
          event,
          request: event.request
        });
      })();
    }

    /**
     * This method can be used to perform a make a standalone request outside the
     * context of the [Workbox Router]{@link workbox.routing.Router}.
     *
     * See "[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)"
     * for more usage information.
     *
     * @param {Object} options
     * @param {Request|string} options.request Either a
     *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}
     *     object, or a string URL, corresponding to the request to be made.
     * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will
     *     be called automatically to extend the service worker's lifetime.
     * @return {Promise<Response>}
     */
    makeRequest({ event, request }) {
      var _this2 = this;

      return babelHelpers.asyncToGenerator(function* () {
        if (typeof request === 'string') {
          request = new Request(request);
        }

        {
          assert_mjs.assert.isInstance(request, Request, {
            moduleName: 'workbox-strategies',
            className: 'NetworkOnly',
>>>>>>> 2cfd330b (move react to root dir)
            funcName: 'handle',
            paramName: 'request'
          });
        }

<<<<<<< HEAD
        const fetchAndCachePromise = handler.fetchAndCachePut(request).catch(() => {// Swallow this error because a 'no-response' error will be thrown in
          // main handler return flow. This will be in the `waitUntil()` flow.
        });
        void handler.waitUntil(fetchAndCachePromise);
        let response = await handler.cacheMatch(request);
        let error;

        if (response) {
          {
            logs.push(`Found a cached response in the '${this.cacheName}'` + ` cache. Will update with the network response in the background.`);
          }
        } else {
          {
            logs.push(`No response found in the '${this.cacheName}' cache. ` + `Will wait for the network response.`);
          }

          try {
            // NOTE(philipwalton): Really annoying that we have to type cast here.
            // https://github.com/microsoft/TypeScript/issues/20006
            response = await fetchAndCachePromise;
          } catch (err) {
            if (err instanceof Error) {
              error = err;
=======
        let error;
        let response;
        try {
          response = yield fetchWrapper_mjs.fetchWrapper.fetch({
            request,
            event,
            fetchOptions: _this2._fetchOptions,
            plugins: _this2._plugins
          });
        } catch (err) {
          error = err;
        }

        {
          logger_mjs.logger.groupCollapsed(messages.strategyStart('NetworkOnly', request));
          if (response) {
            logger_mjs.logger.log(`Got response from network.`);
          } else {
            logger_mjs.logger.log(`Unable to get a response from the network.`);
          }
          messages.printFinalResponse(response);
          logger_mjs.logger.groupEnd();
        }

        // If there was an error thrown, re-throw it to ensure the Routers
        // catch handler is triggered.
        if (error) {
          throw error;
        }

        return response;
      })();
    }
  }

  /*
   Copyright 2018 Google Inc. All Rights Reserved.
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
  */

  /**
   * An implementation of a
   * [stale-while-revalidate]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate}
   * request strategy.
   *
   * Resources are requested from both the cache and the network in parallel.
   * The strategy will respond with the cached version if available, otherwise
   * wait for the network response. The cache is updated with the network response
   * with each successful request.
   *
   * By default, this strategy will cache responses with a 200 status code as
   * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.
   * Opaque responses are are cross-origin requests where the response doesn't
   * support [CORS]{@link https://enable-cors.org/}.
   *
   * @memberof workbox.strategies
   */
  class StaleWhileRevalidate {
    /**
     * @param {Object} options
     * @param {string} options.cacheName Cache name to store and retrieve
     * requests. Defaults to cache names provided by
     * [workbox-core]{@link workbox.core.cacheNames}.
     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
     * to use in conjunction with this caching strategy.
     * @param {Object} options.fetchOptions Values passed along to the
     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)
     * of all fetch() requests made by this strategy.
     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)
     */
    constructor(options = {}) {
      this._cacheName = cacheNames_mjs.cacheNames.getRuntimeName(options.cacheName);
      this._plugins = options.plugins || [];

      if (options.plugins) {
        let isUsingCacheWillUpdate = options.plugins.some(plugin => !!plugin.cacheWillUpdate);
        this._plugins = isUsingCacheWillUpdate ? options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];
      } else {
        // No plugins passed in, use the default plugin.
        this._plugins = [cacheOkAndOpaquePlugin];
      }

      this._fetchOptions = options.fetchOptions || null;
      this._matchOptions = options.matchOptions || null;
    }

    /**
     * This method will perform a request strategy and follows an API that
     * will work with the
     * [Workbox Router]{@link workbox.routing.Router}.
     *
     * @param {Object} options
     * @param {FetchEvent} options.event The fetch event to run this strategy
     * against.
     * @return {Promise<Response>}
     */
    handle({ event }) {
      var _this = this;

      return babelHelpers.asyncToGenerator(function* () {
        {
          assert_mjs.assert.isInstance(event, FetchEvent, {
            moduleName: 'workbox-strategies',
            className: 'StaleWhileRevalidate',
            funcName: 'handle',
            paramName: 'event'
          });
        }

        return _this.makeRequest({
          event,
          request: event.request
        });
      })();
    }

    /**
     * This method can be used to perform a make a standalone request outside the
     * context of the [Workbox Router]{@link workbox.routing.Router}.
     *
     * See "[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)"
     * for more usage information.
     *
     * @param {Object} options
     * @param {Request|string} options.request Either a
     *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}
     *     object, or a string URL, corresponding to the request to be made.
     * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will
     *     be called automatically to extend the service worker's lifetime.
     * @return {Promise<Response>}
     */
    makeRequest({ event, request }) {
      var _this2 = this;

      return babelHelpers.asyncToGenerator(function* () {
        const logs = [];

        if (typeof request === 'string') {
          request = new Request(request);
        }

        {
          assert_mjs.assert.isInstance(request, Request, {
            moduleName: 'workbox-strategies',
            className: 'StaleWhileRevalidate',
            funcName: 'handle',
            paramName: 'request'
          });
        }

        const fetchAndCachePromise = _this2._getFromNetwork({ request, event });

        let response = yield cacheWrapper_mjs.cacheWrapper.match({
          cacheName: _this2._cacheName,
          request,
          event,
          matchOptions: _this2._matchOptions,
          plugins: _this2._plugins
        });

        if (response) {
          {
            logs.push(`Found a cached response in the '${_this2._cacheName}'` + ` cache. Will update with the network response in the background.`);
          }

          if (event) {
            try {
              event.waitUntil(fetchAndCachePromise);
            } catch (error) {
              {
                logger_mjs.logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache for '${getFriendlyURL_mjs.getFriendlyURL(event.request.url)}'.`);
              }
            }
          }
        } else {
          {
            logs.push(`No response found in the '${_this2._cacheName}' cache. ` + `Will wait for the network response.`);
          }
          response = yield fetchAndCachePromise;
        }

        {
          logger_mjs.logger.groupCollapsed(messages.strategyStart('StaleWhileRevalidate', request));
          for (let log of logs) {
            logger_mjs.logger.log(log);
          }
          messages.printFinalResponse(response);
          logger_mjs.logger.groupEnd();
        }

        return response;
      })();
    }

    /**
     * @param {Object} options
     * @param {Request} options.request
     * @param {Event} [options.event]
     * @return {Promise<Response>}
     *
     * @private
     */
    _getFromNetwork({ request, event }) {
      var _this3 = this;

      return babelHelpers.asyncToGenerator(function* () {
        const response = yield fetchWrapper_mjs.fetchWrapper.fetch({
          request,
          event,
          fetchOptions: _this3._fetchOptions,
          plugins: _this3._plugins
        });

        const cachePutPromise = cacheWrapper_mjs.cacheWrapper.put({
          cacheName: _this3._cacheName,
          request,
          response: response.clone(),
          event,
          plugins: _this3._plugins
        });

        if (event) {
          try {
            event.waitUntil(cachePutPromise);
          } catch (error) {
            {
              logger_mjs.logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache for '${getFriendlyURL_mjs.getFriendlyURL(event.request.url)}'.`);
>>>>>>> 2cfd330b (move react to root dir)
            }
          }
        }

<<<<<<< HEAD
        {
          logger_js.logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));

          for (const log of logs) {
            logger_js.logger.log(log);
          }

          messages.printFinalResponse(response);
          logger_js.logger.groupEnd();
        }

        if (!response) {
          throw new WorkboxError_js.WorkboxError('no-response', {
            url: request.url,
            error
          });
        }

        return response;
      }

    }

    exports.CacheFirst = CacheFirst;
    exports.CacheOnly = CacheOnly;
    exports.NetworkFirst = NetworkFirst;
    exports.NetworkOnly = NetworkOnly;
    exports.StaleWhileRevalidate = StaleWhileRevalidate;
    exports.Strategy = Strategy;
    exports.StrategyHandler = StrategyHandler;

    return exports;

}({}, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private));
=======
        return response;
      })();
    }
  }

  /*
    Copyright 2017 Google Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        https://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
  */

  var publicAPI = /*#__PURE__*/Object.freeze({
    CacheFirst: CacheFirst,
    CacheOnly: CacheOnly,
    NetworkFirst: NetworkFirst,
    NetworkOnly: NetworkOnly,
    StaleWhileRevalidate: StaleWhileRevalidate
  });

  /*
   Copyright 2016 Google Inc. All Rights Reserved.
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
  */

  /**
   * @function workbox.strategies.cacheFirst
   * @param {Object} options See the {@link workbox.strategies.CacheFirst}
   * constructor for more info.
   */

  /**
   * @function workbox.strategies.cacheOnly
   * @param {Object} options See the {@link workbox.strategies.CacheOnly}
   * constructor for more info.
   */

  /**
   * @function workbox.strategies.networkFirst
   * @param {Object} options See the {@link workbox.strategies.NetworkFirst}
   * constructor for more info.
   */

  /**
   * @function workbox.strategies.networkOnly
   * @param {Object} options See the {@link workbox.strategies.NetworkOnly}
   * constructor for more info.
   */

  /**
   * @function workbox.strategies.staleWhileRevalidate
   * @param {Object} options See the
   * {@link workbox.strategies.StaleWhileRevalidate} constructor for more info.
   */

  const mapping = {
    cacheFirst: CacheFirst,
    cacheOnly: CacheOnly,
    networkFirst: NetworkFirst,
    networkOnly: NetworkOnly,
    staleWhileRevalidate: StaleWhileRevalidate
  };

  const defaultExport = {};
  Object.keys(mapping).forEach(keyName => {
    defaultExport[keyName] = (options = {}) => {
      const StrategyClass = mapping[keyName];
      return new StrategyClass(Object.assign(options));
    };
  });

  /*
    Copyright 2017 Google Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        https://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
  */

  const finalExport = Object.assign(defaultExport, publicAPI);

  return finalExport;

}(workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private));

>>>>>>> 2cfd330b (move react to root dir)
//# sourceMappingURL=workbox-strategies.dev.js.map
