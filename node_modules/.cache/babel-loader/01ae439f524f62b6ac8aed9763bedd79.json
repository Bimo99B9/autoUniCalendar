{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compile = void 0;\n\nvar boolbase_1 = require(\"boolbase\");\n/**\n * Returns a function that checks if an elements index matches the given rule\n * highly optimized to return the fastest solution.\n *\n * @param parsed A tuple [a, b], as returned by `parse`.\n * @returns A highly optimized function that returns whether an index matches the nth-check.\n * @example\n * const check = nthCheck.compile([2, 3]);\n *\n * check(0); // `false`\n * check(1); // `false`\n * check(2); // `true`\n * check(3); // `false`\n * check(4); // `true`\n * check(5); // `false`\n * check(6); // `true`\n */\n\n\nfunction compile(parsed) {\n  var a = parsed[0]; // Subtract 1 from `b`, to convert from one- to zero-indexed.\n\n  var b = parsed[1] - 1;\n  /*\n   * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.\n   * Besides, the specification states that no elements are\n   * matched when `a` and `b` are 0.\n   *\n   * `b < 0` here as we subtracted 1 from `b` above.\n   */\n\n  if (b < 0 && a <= 0) return boolbase_1.falseFunc; // When `a` is in the range -1..1, it matches any element (so only `b` is checked).\n\n  if (a === -1) return function (index) {\n    return index <= b;\n  };\n  if (a === 0) return function (index) {\n    return index === b;\n  }; // When `b <= 0` and `a === 1`, they match any element.\n\n  if (a === 1) return b < 0 ? boolbase_1.trueFunc : function (index) {\n    return index >= b;\n  };\n  /*\n   * Otherwise, modulo can be used to check if there is a match.\n   *\n   * Modulo doesn't care about the sign, so let's use `a`s absolute value.\n   */\n\n  var absA = Math.abs(a); // Get `b mod a`, + a if this is negative.\n\n  var bMod = (b % absA + absA) % absA;\n  return a > 1 ? function (index) {\n    return index >= b && index % absA === bMod;\n  } : function (index) {\n    return index <= b && index % absA === bMod;\n  };\n}\n\nexports.compile = compile;","map":{"version":3,"names":["Object","defineProperty","exports","value","compile","boolbase_1","require","parsed","a","b","falseFunc","index","trueFunc","absA","Math","abs","bMod"],"sources":["/home/mier/git/epiCalendar/node_modules/nth-check/lib/compile.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.compile = void 0;\nvar boolbase_1 = require(\"boolbase\");\n/**\n * Returns a function that checks if an elements index matches the given rule\n * highly optimized to return the fastest solution.\n *\n * @param parsed A tuple [a, b], as returned by `parse`.\n * @returns A highly optimized function that returns whether an index matches the nth-check.\n * @example\n * const check = nthCheck.compile([2, 3]);\n *\n * check(0); // `false`\n * check(1); // `false`\n * check(2); // `true`\n * check(3); // `false`\n * check(4); // `true`\n * check(5); // `false`\n * check(6); // `true`\n */\nfunction compile(parsed) {\n    var a = parsed[0];\n    // Subtract 1 from `b`, to convert from one- to zero-indexed.\n    var b = parsed[1] - 1;\n    /*\n     * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.\n     * Besides, the specification states that no elements are\n     * matched when `a` and `b` are 0.\n     *\n     * `b < 0` here as we subtracted 1 from `b` above.\n     */\n    if (b < 0 && a <= 0)\n        return boolbase_1.falseFunc;\n    // When `a` is in the range -1..1, it matches any element (so only `b` is checked).\n    if (a === -1)\n        return function (index) { return index <= b; };\n    if (a === 0)\n        return function (index) { return index === b; };\n    // When `b <= 0` and `a === 1`, they match any element.\n    if (a === 1)\n        return b < 0 ? boolbase_1.trueFunc : function (index) { return index >= b; };\n    /*\n     * Otherwise, modulo can be used to check if there is a match.\n     *\n     * Modulo doesn't care about the sign, so let's use `a`s absolute value.\n     */\n    var absA = Math.abs(a);\n    // Get `b mod a`, + a if this is negative.\n    var bMod = ((b % absA) + absA) % absA;\n    return a > 1\n        ? function (index) { return index >= b && index % absA === bMod; }\n        : function (index) { return index <= b && index % absA === bMod; };\n}\nexports.compile = compile;\n"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAAEC,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;;AACA,IAAIC,UAAU,GAAGC,OAAO,CAAC,UAAD,CAAxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASF,OAAT,CAAiBG,MAAjB,EAAyB;EACrB,IAAIC,CAAC,GAAGD,MAAM,CAAC,CAAD,CAAd,CADqB,CAErB;;EACA,IAAIE,CAAC,GAAGF,MAAM,CAAC,CAAD,CAAN,GAAY,CAApB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;;EACI,IAAIE,CAAC,GAAG,CAAJ,IAASD,CAAC,IAAI,CAAlB,EACI,OAAOH,UAAU,CAACK,SAAlB,CAZiB,CAarB;;EACA,IAAIF,CAAC,KAAK,CAAC,CAAX,EACI,OAAO,UAAUG,KAAV,EAAiB;IAAE,OAAOA,KAAK,IAAIF,CAAhB;EAAoB,CAA9C;EACJ,IAAID,CAAC,KAAK,CAAV,EACI,OAAO,UAAUG,KAAV,EAAiB;IAAE,OAAOA,KAAK,KAAKF,CAAjB;EAAqB,CAA/C,CAjBiB,CAkBrB;;EACA,IAAID,CAAC,KAAK,CAAV,EACI,OAAOC,CAAC,GAAG,CAAJ,GAAQJ,UAAU,CAACO,QAAnB,GAA8B,UAAUD,KAAV,EAAiB;IAAE,OAAOA,KAAK,IAAIF,CAAhB;EAAoB,CAA5E;EACJ;AACJ;AACA;AACA;AACA;;EACI,IAAII,IAAI,GAAGC,IAAI,CAACC,GAAL,CAASP,CAAT,CAAX,CA1BqB,CA2BrB;;EACA,IAAIQ,IAAI,GAAG,CAAEP,CAAC,GAAGI,IAAL,GAAaA,IAAd,IAAsBA,IAAjC;EACA,OAAOL,CAAC,GAAG,CAAJ,GACD,UAAUG,KAAV,EAAiB;IAAE,OAAOA,KAAK,IAAIF,CAAT,IAAcE,KAAK,GAAGE,IAAR,KAAiBG,IAAtC;EAA6C,CAD/D,GAED,UAAUL,KAAV,EAAiB;IAAE,OAAOA,KAAK,IAAIF,CAAT,IAAcE,KAAK,GAAGE,IAAR,KAAiBG,IAAtC;EAA6C,CAFtE;AAGH;;AACDd,OAAO,CAACE,OAAR,GAAkBA,OAAlB"},"metadata":{},"sourceType":"script"}