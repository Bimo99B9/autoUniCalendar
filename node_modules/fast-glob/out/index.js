<<<<<<< HEAD
"use strict";
const taskManager = require("./managers/tasks");
const patternManager = require("./managers/patterns");
const async_1 = require("./providers/async");
const stream_1 = require("./providers/stream");
const sync_1 = require("./providers/sync");
const settings_1 = require("./settings");
const utils = require("./utils");
async function FastGlob(source, options) {
    assertPatternsInput(source);
    const works = getWorks(source, async_1.default, options);
    const result = await Promise.all(works);
    return utils.array.flatten(result);
}
// https://github.com/typescript-eslint/typescript-eslint/issues/60
// eslint-disable-next-line no-redeclare
(function (FastGlob) {
    function sync(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, sync_1.default, options);
        return utils.array.flatten(works);
    }
    FastGlob.sync = sync;
    function stream(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, stream_1.default, options);
        /**
         * The stream returned by the provider cannot work with an asynchronous iterator.
         * To support asynchronous iterators, regardless of the number of tasks, we always multiplex streams.
         * This affects performance (+25%). I don't see best solution right now.
         */
        return utils.stream.merge(works);
    }
    FastGlob.stream = stream;
    function generateTasks(source, options) {
        assertPatternsInput(source);
        const patterns = patternManager.transform([].concat(source));
        const settings = new settings_1.default(options);
        return taskManager.generate(patterns, settings);
    }
    FastGlob.generateTasks = generateTasks;
    function isDynamicPattern(source, options) {
        assertPatternsInput(source);
        const settings = new settings_1.default(options);
        return utils.pattern.isDynamicPattern(source, settings);
    }
    FastGlob.isDynamicPattern = isDynamicPattern;
    function escapePath(source) {
        assertPatternsInput(source);
        return utils.path.escape(source);
    }
    FastGlob.escapePath = escapePath;
})(FastGlob || (FastGlob = {}));
function getWorks(source, _Provider, options) {
    const patterns = patternManager.transform([].concat(source));
    const settings = new settings_1.default(options);
    const tasks = taskManager.generate(patterns, settings);
    const provider = new _Provider(settings);
    return tasks.map(provider.read, provider);
}
function assertPatternsInput(input) {
    const source = [].concat(input);
    const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
    if (!isValidSource) {
        throw new TypeError('Patterns must be a string (non empty) or an array of strings');
    }
}
module.exports = FastGlob;
=======
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var optionsManager = require("./managers/options");
var taskManager = require("./managers/tasks");
var reader_async_1 = require("./providers/reader-async");
var reader_stream_1 = require("./providers/reader-stream");
var reader_sync_1 = require("./providers/reader-sync");
var arrayUtils = require("./utils/array");
var streamUtils = require("./utils/stream");
/**
 * Synchronous API.
 */
function sync(source, opts) {
    assertPatternsInput(source);
    var works = getWorks(source, reader_sync_1.default, opts);
    return arrayUtils.flatten(works);
}
exports.sync = sync;
/**
 * Asynchronous API.
 */
function async(source, opts) {
    try {
        assertPatternsInput(source);
    }
    catch (error) {
        return Promise.reject(error);
    }
    var works = getWorks(source, reader_async_1.default, opts);
    return Promise.all(works).then(arrayUtils.flatten);
}
exports.async = async;
/**
 * Stream API.
 */
function stream(source, opts) {
    assertPatternsInput(source);
    var works = getWorks(source, reader_stream_1.default, opts);
    return streamUtils.merge(works);
}
exports.stream = stream;
/**
 * Return a set of tasks based on provided patterns.
 */
function generateTasks(source, opts) {
    assertPatternsInput(source);
    var patterns = [].concat(source);
    var options = optionsManager.prepare(opts);
    return taskManager.generate(patterns, options);
}
exports.generateTasks = generateTasks;
/**
 * Returns a set of works based on provided tasks and class of the reader.
 */
function getWorks(source, _Reader, opts) {
    var patterns = [].concat(source);
    var options = optionsManager.prepare(opts);
    var tasks = taskManager.generate(patterns, options);
    var reader = new _Reader(options);
    return tasks.map(reader.read, reader);
}
function assertPatternsInput(source) {
    if ([].concat(source).every(isString)) {
        return;
    }
    throw new TypeError('Patterns must be a string or an array of strings');
}
function isString(source) {
    /* tslint:disable-next-line strict-type-predicates */
    return typeof source === 'string';
}
>>>>>>> 2cfd330b (move react to root dir)
