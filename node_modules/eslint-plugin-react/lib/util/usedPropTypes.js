/**
 * @fileoverview Common used propTypes detection functionality.
 */
<<<<<<< HEAD

'use strict';

const astUtil = require('./ast');
const componentUtil = require('./componentUtil');
const testReactVersion = require('./version').testReactVersion;
const ast = require('./ast');
=======
'use strict';

const astUtil = require('./ast');
const versionUtil = require('./version');
>>>>>>> 2cfd330b (move react to root dir)

// ------------------------------------------------------------------------------
// Constants
// ------------------------------------------------------------------------------

<<<<<<< HEAD
const LIFE_CYCLE_METHODS = ['componentWillReceiveProps', 'shouldComponentUpdate', 'componentWillUpdate', 'componentDidUpdate'];
const ASYNC_SAFE_LIFE_CYCLE_METHODS = ['getDerivedStateFromProps', 'getSnapshotBeforeUpdate', 'UNSAFE_componentWillReceiveProps', 'UNSAFE_componentWillUpdate'];

function createPropVariables() {
  /** @type {Map<string, string[]>} Maps the variable to its definition. `props.a.b` is stored as `['a', 'b']` */
  let propVariables = new Map();
  let hasBeenWritten = false;
  const stack = [{ propVariables, hasBeenWritten }];
  return {
    pushScope() {
      // popVariables is not copied until first write.
      stack.push({ propVariables, hasBeenWritten: false });
    },
    popScope() {
      stack.pop();
      propVariables = stack[stack.length - 1].propVariables;
      hasBeenWritten = stack[stack.length - 1].hasBeenWritten;
    },
    /**
     * Add a variable name to the current scope
     * @param {string} name
     * @param {string[]} allNames Example: `props.a.b` should be formatted as `['a', 'b']`
     * @returns {Map<string, string[]>}
     */
    set(name, allNames) {
      if (!hasBeenWritten) {
        // copy on write
        propVariables = new Map(propVariables);
        Object.assign(stack[stack.length - 1], { propVariables, hasBeenWritten: true });
        stack[stack.length - 1].hasBeenWritten = true;
      }
      return propVariables.set(name, allNames);
    },
    /**
     * Get the definition of a variable.
     * @param {string} name
     * @returns {string[]} Example: `props.a.b` is represented by `['a', 'b']`
     */
    get(name) {
      return propVariables.get(name);
    },
  };
}

/**
 * Checks if the string is one of `props`, `nextProps`, or `prevProps`
 * @param {string} name The AST node being checked.
 * @returns {Boolean} True if the prop name matches
 */
function isCommonVariableNameForProps(name) {
  return name === 'props' || name === 'nextProps' || name === 'prevProps';
=======
const DIRECT_PROPS_REGEX = /^props\s*(\.|\[)/;
const DIRECT_NEXT_PROPS_REGEX = /^nextProps\s*(\.|\[)/;
const DIRECT_PREV_PROPS_REGEX = /^prevProps\s*(\.|\[)/;
const LIFE_CYCLE_METHODS = ['componentWillReceiveProps', 'shouldComponentUpdate', 'componentWillUpdate', 'componentDidUpdate'];
const ASYNC_SAFE_LIFE_CYCLE_METHODS = ['getDerivedStateFromProps', 'getSnapshotBeforeUpdate', 'UNSAFE_componentWillReceiveProps', 'UNSAFE_componentWillUpdate'];

/**
 * Checks if a prop init name matches common naming patterns
 * @param {ASTNode} node The AST node being checked.
 * @returns {Boolean} True if the prop name matches
 */
function isPropAttributeName (node) {
  return (
    node.init.name === 'props' ||
    node.init.name === 'nextProps' ||
    node.init.name === 'prevProps'
  );
>>>>>>> 2cfd330b (move react to root dir)
}

/**
 * Checks if the component must be validated
 * @param {Object} component The component to process
 * @returns {Boolean} True if the component must be validated, false if not.
 */
function mustBeValidated(component) {
  return !!(component && !component.ignorePropsValidation);
}

<<<<<<< HEAD
/**
 * Check if we are in a lifecycle method
 * @param {object} context
 * @param {boolean} checkAsyncSafeLifeCycles
 * @return {boolean} true if we are in a class constructor, false if not
 */
function inLifeCycleMethod(context, checkAsyncSafeLifeCycles) {
  let scope = context.getScope();
  while (scope) {
    if (scope.block && scope.block.parent && scope.block.parent.key) {
      const name = scope.block.parent.key.name;

      if (LIFE_CYCLE_METHODS.indexOf(name) >= 0) {
        return true;
      }
      if (checkAsyncSafeLifeCycles && ASYNC_SAFE_LIFE_CYCLE_METHODS.indexOf(name) >= 0) {
        return true;
      }
    }
    scope = scope.upper;
  }
  return false;
}

/**
 * Returns true if the given node is a React Component lifecycle method
 * @param {ASTNode} node The AST node being checked.
 * @param {boolean} checkAsyncSafeLifeCycles
 * @return {Boolean} True if the node is a lifecycle method
 */
function isNodeALifeCycleMethod(node, checkAsyncSafeLifeCycles) {
  const nodeKeyName = (node.key || /** @type {ASTNode} */ ({})).name;

  if (node.kind === 'constructor') {
    return true;
  }
  if (LIFE_CYCLE_METHODS.indexOf(nodeKeyName) >= 0) {
    return true;
  }
  if (checkAsyncSafeLifeCycles && ASYNC_SAFE_LIFE_CYCLE_METHODS.indexOf(nodeKeyName) >= 0) {
    return true;
  }

  return false;
}

/**
 * Returns true if the given node is inside a React Component lifecycle
 * method.
 * @param {ASTNode} node The AST node being checked.
 * @param {boolean} checkAsyncSafeLifeCycles
 * @return {Boolean} True if the node is inside a lifecycle method
 */
function isInLifeCycleMethod(node, checkAsyncSafeLifeCycles) {
  if ((node.type === 'MethodDefinition' || node.type === 'Property') && isNodeALifeCycleMethod(node, checkAsyncSafeLifeCycles)) {
    return true;
  }

  if (node.parent) {
    return isInLifeCycleMethod(node.parent, checkAsyncSafeLifeCycles);
  }

  return false;
}

/**
 * Check if a function node is a setState updater
 * @param {ASTNode} node a function node
 * @return {boolean}
 */
function isSetStateUpdater(node) {
  const unwrappedParentCalleeNode = node.parent && node.parent.type === 'CallExpression'
    && ast.unwrapTSAsExpression(node.parent.callee);

  return unwrappedParentCalleeNode
    && unwrappedParentCalleeNode.property
    && unwrappedParentCalleeNode.property.name === 'setState'
    // Make sure we are in the updater not the callback
    && node.parent.arguments[0] === node;
}

function isPropArgumentInSetStateUpdater(context, name) {
  if (typeof name !== 'string') {
    return;
  }
  let scope = context.getScope();
  while (scope) {
    const unwrappedParentCalleeNode = scope.block
      && scope.block.parent
      && scope.block.parent.type === 'CallExpression'
      && ast.unwrapTSAsExpression(scope.block.parent.callee);
    if (
      unwrappedParentCalleeNode
      && unwrappedParentCalleeNode.property
      && unwrappedParentCalleeNode.property.name === 'setState'
      // Make sure we are in the updater not the callback
      && scope.block.parent.arguments[0].range[0] === scope.block.range[0]
      && scope.block.parent.arguments[0].params
      && scope.block.parent.arguments[0].params.length > 1
    ) {
      return scope.block.parent.arguments[0].params[1].name === name;
    }
    scope = scope.upper;
  }
  return false;
}

/**
 * @param {Context} context
 * @returns {boolean}
 */
function isInClassComponent(context) {
  return !!(componentUtil.getParentES6Component(context) || componentUtil.getParentES5Component(context));
}

/**
 * Checks if the node is `this.props`
 * @param {ASTNode|undefined} node
 * @returns {boolean}
 */
function isThisDotProps(node) {
  return !!node
    && node.type === 'MemberExpression'
    && ast.unwrapTSAsExpression(node.object).type === 'ThisExpression'
    && node.property.name === 'props';
}

/**
 * Checks if the prop has spread operator.
 * @param {object} context
 * @param {ASTNode} node The AST node being marked.
 * @returns {Boolean} True if the prop has spread operator, false if not.
 */
function hasSpreadOperator(context, node) {
  const tokens = context.getSourceCode().getTokens(node);
  return tokens.length && tokens[0].value === '...';
}

/**
 * Checks if the node is a propTypes usage of the form `this.props.*`, `props.*`, `prevProps.*`, or `nextProps.*`.
 * @param {ASTNode} node
 * @param {Context} context
 * @param {Object} utils
 * @param {boolean} checkAsyncSafeLifeCycles
 * @returns {boolean}
 */
function isPropTypesUsageByMemberExpression(node, context, utils, checkAsyncSafeLifeCycles) {
  const unwrappedObjectNode = ast.unwrapTSAsExpression(node.object);

  if (isInClassComponent(context)) {
    // this.props.*
    if (isThisDotProps(unwrappedObjectNode)) {
      return true;
    }
    // props.* or prevProps.* or nextProps.*
    if (
      isCommonVariableNameForProps(unwrappedObjectNode.name)
      && (inLifeCycleMethod(context, checkAsyncSafeLifeCycles) || astUtil.inConstructor(context))
    ) {
      return true;
    }
    // this.setState((_, props) => props.*))
    if (isPropArgumentInSetStateUpdater(context, unwrappedObjectNode.name)) {
      return true;
    }
    return false;
  }
  // props.* in function component
  return unwrappedObjectNode.name === 'props' && !ast.isAssignmentLHS(node);
}

/**
 * Retrieve the name of a property node
 * @param {ASTNode} node The AST node with the property.
 * @param {Context} context
 * @param {Object} utils
 * @param {boolean} checkAsyncSafeLifeCycles
 * @return {string|undefined} the name of the property or undefined if not found
 */
function getPropertyName(node, context, utils, checkAsyncSafeLifeCycles) {
  const property = node.property;
  if (property) {
    switch (property.type) {
      case 'Identifier':
        if (node.computed) {
          return '__COMPUTED_PROP__';
        }
        return property.name;
      case 'MemberExpression':
        return;
      case 'Literal':
        // Accept computed properties that are literal strings
        if (typeof property.value === 'string') {
          return property.value;
        }
        // Accept number as well but only accept props[123]
        if (typeof property.value === 'number') {
          if (isPropTypesUsageByMemberExpression(node, context, utils, checkAsyncSafeLifeCycles)) {
            return property.raw;
          }
        }
        // falls through
      default:
        if (node.computed) {
          return '__COMPUTED_PROP__';
        }
        break;
    }
  }
}

module.exports = function usedPropTypesInstructions(context, components, utils) {
  const checkAsyncSafeLifeCycles = testReactVersion(context, '>= 16.3.0');

  const propVariables = createPropVariables();
  const pushScope = propVariables.pushScope;
  const popScope = propVariables.popScope;
=======
module.exports = function usedPropTypesInstructions(context, components, utils) {
  const sourceCode = context.getSourceCode();
  const checkAsyncSafeLifeCycles = versionUtil.testReactVersion(context, '16.3.0');

  /**
   * Check if we are in a class constructor
   * @return {boolean} true if we are in a class constructor, false if not
   */
  function inComponentWillReceiveProps() {
    let scope = context.getScope();
    while (scope) {
      if (
        scope.block
        && scope.block.parent
        && scope.block.parent.key
        && scope.block.parent.key.name === 'componentWillReceiveProps'
      ) {
        return true;
      }
      scope = scope.upper;
    }
    return false;
  }

  /**
   * Check if we are in a lifecycle method
   * @return {boolean} true if we are in a class constructor, false if not
   **/
  function inLifeCycleMethod() {
    let scope = context.getScope();
    while (scope) {
      if (scope.block && scope.block.parent && scope.block.parent.key) {
        const name = scope.block.parent.key.name;

        if (LIFE_CYCLE_METHODS.indexOf(name) >= 0) {
          return true;
        }
        if (checkAsyncSafeLifeCycles && ASYNC_SAFE_LIFE_CYCLE_METHODS.indexOf(name) >= 0) {
          return true;
        }
      }
      scope = scope.upper;
    }
    return false;
  }

  /**
   * Returns true if the given node is a React Component lifecycle method
   * @param {ASTNode} node The AST node being checked.
   * @return {Boolean} True if the node is a lifecycle method
   */
  function isNodeALifeCycleMethod(node) {
    const nodeKeyName = (node.key || {}).name;

    if (node.kind === 'constructor') {
      return true;
    }
    if (LIFE_CYCLE_METHODS.indexOf(nodeKeyName) >= 0) {
      return true;
    }
    if (checkAsyncSafeLifeCycles && ASYNC_SAFE_LIFE_CYCLE_METHODS.indexOf(nodeKeyName) >= 0) {
      return true;
    }

    return false;
  }

  /**
   * Returns true if the given node is inside a React Component lifecycle
   * method.
   * @param {ASTNode} node The AST node being checked.
   * @return {Boolean} True if the node is inside a lifecycle method
   */
  function isInLifeCycleMethod(node) {
    if ((node.type === 'MethodDefinition' || node.type === 'Property') && isNodeALifeCycleMethod(node)) {
      return true;
    }

    if (node.parent) {
      return isInLifeCycleMethod(node.parent);
    }

    return false;
  }

  /**
   * Check if the current node is in a setState updater method
   * @return {boolean} true if we are in a setState updater, false if not
   */
  function inSetStateUpdater() {
    let scope = context.getScope();
    while (scope) {
      if (
        scope.block && scope.block.parent
        && scope.block.parent.type === 'CallExpression'
        && scope.block.parent.callee.property
        && scope.block.parent.callee.property.name === 'setState'
        // Make sure we are in the updater not the callback
        && scope.block.parent.arguments[0].start === scope.block.start
      ) {
        return true;
      }
      scope = scope.upper;
    }
    return false;
  }

  function isPropArgumentInSetStateUpdater(node) {
    let scope = context.getScope();
    while (scope) {
      if (
        scope.block && scope.block.parent
        && scope.block.parent.type === 'CallExpression'
        && scope.block.parent.callee.property
        && scope.block.parent.callee.property.name === 'setState'
        // Make sure we are in the updater not the callback
        && scope.block.parent.arguments[0].start === scope.block.start
        && scope.block.parent.arguments[0].params
        && scope.block.parent.arguments[0].params.length > 1
      ) {
        return scope.block.parent.arguments[0].params[1].name === node.object.name;
      }
      scope = scope.upper;
    }
    return false;
  }

  /**
   * Checks if the prop has spread operator.
   * @param {ASTNode} node The AST node being marked.
   * @returns {Boolean} True if the prop has spread operator, false if not.
   */
  function hasSpreadOperator(node) {
    const tokens = sourceCode.getTokens(node);
    return tokens.length && tokens[0].value === '...';
  }

  /**
   * Removes quotes from around an identifier.
   * @param {string} the identifier to strip
   */
  function stripQuotes(string) {
    return string.replace(/^\'|\'$/g, '');
  }

  /**
   * Retrieve the name of a key node
   * @param {ASTNode} node The AST node with the key.
   * @return {string} the name of the key
   */
  function getKeyValue(node) {
    if (node.type === 'ObjectTypeProperty') {
      const tokens = context.getFirstTokens(node, 2);
      return (tokens[0].value === '+' || tokens[0].value === '-'
        ? tokens[1].value
        : stripQuotes(tokens[0].value)
      );
    }
    const key = node.key || node.argument;
    return key.type === 'Identifier' ? key.name : key.value;
  }

  /**
   * Check if we are in a class constructor
   * @return {boolean} true if we are in a class constructor, false if not
   */
  function inConstructor() {
    let scope = context.getScope();
    while (scope) {
      if (scope.block && scope.block.parent && scope.block.parent.kind === 'constructor') {
        return true;
      }
      scope = scope.upper;
    }
    return false;
  }

  /**
   * Retrieve the name of a property node
   * @param {ASTNode} node The AST node with the property.
   * @return {string} the name of the property or undefined if not found
   */
  function getPropertyName(node) {
    const isDirectProp = DIRECT_PROPS_REGEX.test(sourceCode.getText(node));
    const isDirectNextProp = DIRECT_NEXT_PROPS_REGEX.test(sourceCode.getText(node));
    const isDirectPrevProp = DIRECT_PREV_PROPS_REGEX.test(sourceCode.getText(node));
    const isDirectSetStateProp = isPropArgumentInSetStateUpdater(node);
    const isInClassComponent = utils.getParentES6Component() || utils.getParentES5Component();
    const isNotInConstructor = !inConstructor(node);
    const isNotInLifeCycleMethod = !inLifeCycleMethod();
    const isNotInSetStateUpdater = !inSetStateUpdater();
    if ((isDirectProp || isDirectNextProp || isDirectPrevProp || isDirectSetStateProp)
      && isInClassComponent
      && isNotInConstructor
      && isNotInLifeCycleMethod
      && isNotInSetStateUpdater
    ) {
      return void 0;
    }
    if (!isDirectProp && !isDirectNextProp && !isDirectPrevProp && !isDirectSetStateProp) {
      node = node.parent;
    }
    const property = node.property;
    if (property) {
      switch (property.type) {
        case 'Identifier':
          if (node.computed) {
            return '__COMPUTED_PROP__';
          }
          return property.name;
        case 'MemberExpression':
          return void 0;
        case 'Literal':
          // Accept computed properties that are literal strings
          if (typeof property.value === 'string') {
            return property.value;
          }
          // falls through
        default:
          if (node.computed) {
            return '__COMPUTED_PROP__';
          }
          break;
      }
    }
    return void 0;
  }

  /**
   * Checks if a prop is being assigned a value props.bar = 'bar'
   * @param {ASTNode} node The AST node being checked.
   * @returns {Boolean}
   */
  function isAssignmentToProp(node) {
    return (
      node.parent &&
      node.parent.type === 'AssignmentExpression' &&
      node.parent.left === node
    );
  }

  /**
   * Checks if we are using a prop
   * @param {ASTNode} node The AST node being checked.
   * @returns {Boolean} True if we are using a prop, false if not.
   */
  function isPropTypesUsage(node) {
    const isThisPropsUsage = node.object.type === 'ThisExpression' && node.property.name === 'props';
    const isPropsUsage = isThisPropsUsage || node.object.name === 'nextProps' || node.object.name === 'prevProps';
    const isClassUsage = (
      (utils.getParentES6Component() || utils.getParentES5Component()) &&
      (isThisPropsUsage || isPropArgumentInSetStateUpdater(node))
    );
    const isStatelessFunctionUsage = node.object.name === 'props' && !isAssignmentToProp(node);
    return isClassUsage || isStatelessFunctionUsage || (isPropsUsage && inLifeCycleMethod());
  }
>>>>>>> 2cfd330b (move react to root dir)

  /**
   * Mark a prop type as used
   * @param {ASTNode} node The AST node being marked.
<<<<<<< HEAD
   * @param {string[]} [parentNames]
=======
>>>>>>> 2cfd330b (move react to root dir)
   */
  function markPropTypesAsUsed(node, parentNames) {
    parentNames = parentNames || [];
    let type;
    let name;
    let allNames;
    let properties;
    switch (node.type) {
<<<<<<< HEAD
      case 'OptionalMemberExpression':
      case 'MemberExpression':
        name = getPropertyName(node, context, utils, checkAsyncSafeLifeCycles);
        if (name) {
          allNames = parentNames.concat(name);
          if (
            // Match props.foo.bar, don't match bar[props.foo]
            node.parent.type === 'MemberExpression'
            && node.parent.object === node
          ) {
            markPropTypesAsUsed(node.parent, allNames);
          }
          // Handle the destructuring part of `const {foo} = props.a.b`
          if (
            node.parent.type === 'VariableDeclarator'
            && node.parent.id.type === 'ObjectPattern'
          ) {
            node.parent.id.parent = node.parent; // patch for bug in eslint@4 in which ObjectPattern has no parent
            markPropTypesAsUsed(node.parent.id, allNames);
          }

          // const a = props.a
          if (
            node.parent.type === 'VariableDeclarator'
            && node.parent.id.type === 'Identifier'
          ) {
            propVariables.set(node.parent.id.name, allNames);
          }
          // Do not mark computed props as used.
          type = name !== '__COMPUTED_PROP__' ? 'direct' : null;
=======
      case 'MemberExpression':
        name = getPropertyName(node);
        if (name) {
          allNames = parentNames.concat(name);
          if (node.parent.type === 'MemberExpression') {
            markPropTypesAsUsed(node.parent, allNames);
          }
          // Do not mark computed props as used.
          type = name !== '__COMPUTED_PROP__' ? 'direct' : null;
        } else if (
          node.parent.id &&
          node.parent.id.properties &&
          node.parent.id.properties.length &&
          getKeyValue(node.parent.id.properties[0])
        ) {
          type = 'destructuring';
          properties = node.parent.id.properties;
>>>>>>> 2cfd330b (move react to root dir)
        }
        break;
      case 'ArrowFunctionExpression':
      case 'FunctionDeclaration':
<<<<<<< HEAD
      case 'FunctionExpression': {
=======
      case 'FunctionExpression':
>>>>>>> 2cfd330b (move react to root dir)
        if (node.params.length === 0) {
          break;
        }
        type = 'destructuring';
<<<<<<< HEAD
        const propParam = isSetStateUpdater(node) ? node.params[1] : node.params[0];
        properties = propParam.type === 'AssignmentPattern'
          ? propParam.left.properties
          : propParam.properties;
        break;
      }
      case 'ObjectPattern':
        type = 'destructuring';
        properties = node.properties;
        break;
      case 'TSEmptyBodyFunctionExpression':
=======
        properties = node.params[0].properties;
        if (inSetStateUpdater()) {
          properties = node.params[1].properties;
        }
        break;
      case 'VariableDeclarator':
        for (let i = 0, j = node.id.properties.length; i < j; i++) {
          // let {props: {firstname}} = this
          const thisDestructuring = (
            node.id.properties[i].key && (
              (node.id.properties[i].key.name === 'props' || node.id.properties[i].key.value === 'props') &&
              node.id.properties[i].value.type === 'ObjectPattern'
            )
          );
          // let {firstname} = props
          const genericDestructuring = isPropAttributeName(node) && (
            utils.getParentStatelessComponent() ||
            isInLifeCycleMethod(node)
          );

          if (thisDestructuring) {
            properties = node.id.properties[i].value.properties;
          } else if (genericDestructuring) {
            properties = node.id.properties;
          } else {
            continue;
          }
          type = 'destructuring';
          break;
        }
>>>>>>> 2cfd330b (move react to root dir)
        break;
      default:
        throw new Error(`${node.type} ASTNodes are not handled by markPropTypesAsUsed`);
    }

    const component = components.get(utils.getParentComponent());
<<<<<<< HEAD
    const usedPropTypes = (component && component.usedPropTypes) || [];
    let ignoreUnusedPropTypesValidation = (component && component.ignoreUnusedPropTypesValidation) || false;

    switch (type) {
      case 'direct': {
=======
    const usedPropTypes = component && component.usedPropTypes || [];
    let ignoreUnusedPropTypesValidation = component && component.ignoreUnusedPropTypesValidation || false;

    switch (type) {
      case 'direct':
>>>>>>> 2cfd330b (move react to root dir)
        // Ignore Object methods
        if (name in Object.prototype) {
          break;
        }

<<<<<<< HEAD
        const reportedNode = node.property;
        usedPropTypes.push({
          name,
          allNames,
          node: reportedNode,
        });
        break;
      }
      case 'destructuring': {
        for (let k = 0, l = (properties || []).length; k < l; k++) {
          if (hasSpreadOperator(context, properties[k]) || properties[k].computed) {
            ignoreUnusedPropTypesValidation = true;
            break;
          }
          const propName = ast.getKeyValue(context, properties[k]);

          if (!propName || properties[k].type !== 'Property') {
            break;
          }

          usedPropTypes.push({
            allNames: parentNames.concat([propName]),
            name: propName,
            node: properties[k],
          });

          if (properties[k].value.type === 'ObjectPattern') {
            markPropTypesAsUsed(properties[k].value, parentNames.concat([propName]));
          } else if (properties[k].value.type === 'Identifier') {
            propVariables.set(properties[k].value.name, parentNames.concat(propName));
          }
        }
        break;
      }
=======
        const nodeSource = sourceCode.getText(node);
        const isDirectProp = DIRECT_PROPS_REGEX.test(nodeSource)
          || DIRECT_NEXT_PROPS_REGEX.test(nodeSource)
          || DIRECT_PREV_PROPS_REGEX.test(nodeSource);
        const reportedNode = (
          !isDirectProp && !inConstructor() && !inComponentWillReceiveProps() ?
            node.parent.property :
            node.property
        );
        usedPropTypes.push({
          name: name,
          allNames: allNames,
          node: reportedNode
        });
        break;
      case 'destructuring':
        for (let k = 0, l = (properties || []).length; k < l; k++) {
          if (hasSpreadOperator(properties[k]) || properties[k].computed) {
            ignoreUnusedPropTypesValidation = true;
            break;
          }
          const propName = getKeyValue(properties[k]);

          let currentNode = node;
          allNames = [];
          while (currentNode.property && currentNode.property.name !== 'props') {
            allNames.unshift(currentNode.property.name);
            currentNode = currentNode.object;
          }
          allNames.push(propName);
          if (propName) {
            usedPropTypes.push({
              allNames: allNames,
              name: propName,
              node: properties[k]
            });
          }
        }
        break;
>>>>>>> 2cfd330b (move react to root dir)
      default:
        break;
    }

    components.set(component ? component.node : node, {
<<<<<<< HEAD
      usedPropTypes,
      ignoreUnusedPropTypesValidation,
=======
      usedPropTypes: usedPropTypes,
      ignoreUnusedPropTypesValidation: ignoreUnusedPropTypesValidation
>>>>>>> 2cfd330b (move react to root dir)
    });
  }

  /**
   * @param {ASTNode} node We expect either an ArrowFunctionExpression,
   *   FunctionDeclaration, or FunctionExpression
   */
  function markDestructuredFunctionArgumentsAsUsed(node) {
<<<<<<< HEAD
    const param = node.params && isSetStateUpdater(node) ? node.params[1] : node.params[0];

    const destructuring = param && (
      param.type === 'ObjectPattern'
      || ((param.type === 'AssignmentPattern') && (param.left.type === 'ObjectPattern'))
    );

=======
    const destructuring = node.params && node.params[0] && node.params[0].type === 'ObjectPattern';
>>>>>>> 2cfd330b (move react to root dir)
    if (destructuring && (components.get(node) || components.get(node.parent))) {
      markPropTypesAsUsed(node);
    }
  }

  function handleSetStateUpdater(node) {
<<<<<<< HEAD
    if (!node.params || node.params.length < 2 || !isSetStateUpdater(node)) {
=======
    if (!node.params || node.params.length < 2 || !inSetStateUpdater()) {
>>>>>>> 2cfd330b (move react to root dir)
      return;
    }
    markPropTypesAsUsed(node);
  }

  /**
   * Handle both stateless functions and setState updater functions.
   * @param {ASTNode} node We expect either an ArrowFunctionExpression,
   *   FunctionDeclaration, or FunctionExpression
   */
  function handleFunctionLikeExpressions(node) {
<<<<<<< HEAD
    pushScope();
=======
>>>>>>> 2cfd330b (move react to root dir)
    handleSetStateUpdater(node);
    markDestructuredFunctionArgumentsAsUsed(node);
  }

  function handleCustomValidators(component) {
    const propTypes = component.declaredPropTypes;
    if (!propTypes) {
      return;
    }

<<<<<<< HEAD
    Object.keys(propTypes).forEach((key) => {
      const node = propTypes[key].node;

      if (node && node.value && astUtil.isFunctionLikeExpression(node.value)) {
=======
    Object.keys(propTypes).forEach(key => {
      const node = propTypes[key].node;

      if (node.value && astUtil.isFunctionLikeExpression(node.value)) {
>>>>>>> 2cfd330b (move react to root dir)
        markPropTypesAsUsed(node.value);
      }
    });
  }

  return {
<<<<<<< HEAD
    VariableDeclarator(node) {
      const unwrappedInitNode = ast.unwrapTSAsExpression(node.init);

      // let props = this.props
      if (isThisDotProps(unwrappedInitNode) && isInClassComponent(context) && node.id.type === 'Identifier') {
        propVariables.set(node.id.name, []);
      }

      // Only handles destructuring
      if (node.id.type !== 'ObjectPattern' || !unwrappedInitNode) {
        return;
      }

      // let {props: {firstname}} = this
      const propsProperty = node.id.properties.find((property) => (
        property.key
        && (property.key.name === 'props' || property.key.value === 'props')
      ));

      if (unwrappedInitNode.type === 'ThisExpression' && propsProperty && propsProperty.value.type === 'ObjectPattern') {
        markPropTypesAsUsed(propsProperty.value);
        return;
      }

      // let {props} = this
      if (unwrappedInitNode.type === 'ThisExpression' && propsProperty && propsProperty.value.name === 'props') {
        propVariables.set('props', []);
        return;
      }

      // let {firstname} = props
      if (
        isCommonVariableNameForProps(unwrappedInitNode.name)
        && (utils.getParentStatelessComponent() || isInLifeCycleMethod(node, checkAsyncSafeLifeCycles))
      ) {
        markPropTypesAsUsed(node.id);
        return;
      }

      // let {firstname} = this.props
      if (isThisDotProps(unwrappedInitNode) && isInClassComponent(context)) {
        markPropTypesAsUsed(node.id);
        return;
      }

      // let {firstname} = thing, where thing is defined by const thing = this.props.**.*
      if (propVariables.get(unwrappedInitNode.name)) {
        markPropTypesAsUsed(node.id, propVariables.get(unwrappedInitNode.name));
      }
=======
    VariableDeclarator: function(node) {
      const destructuring = node.init && node.id && node.id.type === 'ObjectPattern';
      // let {props: {firstname}} = this
      const thisDestructuring = destructuring && node.init.type === 'ThisExpression';
      // let {firstname} = props
      const statelessDestructuring = destructuring && isPropAttributeName(node) && (
        utils.getParentStatelessComponent() ||
        isInLifeCycleMethod(node)
      );

      if (!thisDestructuring && !statelessDestructuring) {
        return;
      }
      markPropTypesAsUsed(node);
>>>>>>> 2cfd330b (move react to root dir)
    },

    FunctionDeclaration: handleFunctionLikeExpressions,

    ArrowFunctionExpression: handleFunctionLikeExpressions,

    FunctionExpression: handleFunctionLikeExpressions,

<<<<<<< HEAD
    'FunctionDeclaration:exit': popScope,

    'ArrowFunctionExpression:exit': popScope,

    'FunctionExpression:exit': popScope,

    JSXSpreadAttribute(node) {
      const component = components.get(utils.getParentComponent());
      components.set(component ? component.node : node, {
        ignoreUnusedPropTypesValidation: true,
      });
    },

    'MemberExpression, OptionalMemberExpression'(node) {
      if (isPropTypesUsageByMemberExpression(node, context, utils, checkAsyncSafeLifeCycles)) {
        markPropTypesAsUsed(node);
        return;
      }

      const propVariable = propVariables.get(ast.unwrapTSAsExpression(node.object).name);
      if (propVariable) {
        markPropTypesAsUsed(node, propVariable);
      }
    },

    ObjectPattern(node) {
      // If the object pattern is a destructured props object in a lifecycle
      // method -- mark it for used props.
      if (isNodeALifeCycleMethod(node.parent.parent, checkAsyncSafeLifeCycles) && node.properties.length > 0) {
=======
    JSXSpreadAttribute: function(node) {
      const component = components.get(utils.getParentComponent());
      components.set(component ? component.node : node, {
        ignoreUnusedPropTypesValidation: true
      });
    },

    MemberExpression: function(node) {
      if (isPropTypesUsage(node)) {
        markPropTypesAsUsed(node);
      }
    },

    ObjectPattern: function(node) {
      // If the object pattern is a destructured props object in a lifecycle
      // method -- mark it for used props.
      if (isNodeALifeCycleMethod(node.parent.parent) && node.properties.length > 0) {
>>>>>>> 2cfd330b (move react to root dir)
        markPropTypesAsUsed(node.parent);
      }
    },

<<<<<<< HEAD
    'Program:exit'() {
      const list = components.list();

      Object.keys(list).filter((component) => mustBeValidated(list[component])).forEach((component) => {
        handleCustomValidators(list[component]);
      });
    },
=======
    'Program:exit': function() {
      const list = components.list();

      Object.keys(list).filter(component => mustBeValidated(list[component])).forEach(component => {
        handleCustomValidators(list[component]);
      });
    }
>>>>>>> 2cfd330b (move react to root dir)
  };
};
