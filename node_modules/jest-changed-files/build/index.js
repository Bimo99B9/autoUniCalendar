'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
<<<<<<< HEAD
exports.getChangedFilesForRoots = exports.findRepos = void 0;

function _throat() {
  const data = _interopRequireDefault(require('throat'));

  _throat = function () {
    return data;
  };

  return data;
}

var _git = _interopRequireDefault(require('./git'));

var _hg = _interopRequireDefault(require('./hg'));
=======
exports.findRepos = exports.getChangedFilesForRoots = undefined;

var _git;

function _load_git() {
  return (_git = _interopRequireDefault(require('./git')));
}

var _hg;

function _load_hg() {
  return (_hg = _interopRequireDefault(require('./hg')));
}

var _throat;

function _load_throat() {
  return (_throat = _interopRequireDefault(require('throat')));
}
>>>>>>> 2cfd330b (move react to root dir)

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {default: obj};
}

<<<<<<< HEAD
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
=======
function _asyncToGenerator(fn) {
  return function() {
    var gen = fn.apply(this, arguments);
    return new Promise(function(resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve(value);
        } else {
          return Promise.resolve(value).then(
            function(value) {
              step('next', value);
            },
            function(err) {
              step('throw', err);
            }
          );
        }
      }
      return step('next');
    });
  };
}
/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
>>>>>>> 2cfd330b (move react to root dir)
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
<<<<<<< HEAD
 */
function notEmpty(value) {
  return value != null;
} // This is an arbitrary number. The main goal is to prevent projects with
// many roots (50+) from spawning too many processes at once.

const mutex = (0, _throat().default)(5);

const findGitRoot = dir => mutex(() => _git.default.getRoot(dir));

const findHgRoot = dir => mutex(() => _hg.default.getRoot(dir));

const getChangedFilesForRoots = async (roots, options) => {
  const repos = await findRepos(roots);
  const changedFilesOptions = {
    includePaths: roots,
    ...options
  };
  const gitPromises = Array.from(repos.git).map(repo =>
    _git.default.findChangedFiles(repo, changedFilesOptions)
  );
  const hgPromises = Array.from(repos.hg).map(repo =>
    _hg.default.findChangedFiles(repo, changedFilesOptions)
  );
  const changedFiles = (
    await Promise.all(gitPromises.concat(hgPromises))
  ).reduce((allFiles, changedFilesInTheRepo) => {
    for (const file of changedFilesInTheRepo) {
      allFiles.add(file);
    }

    return allFiles;
  }, new Set());
  return {
    changedFiles,
    repos
  };
};

exports.getChangedFilesForRoots = getChangedFilesForRoots;

const findRepos = async roots => {
  const gitRepos = await Promise.all(
    roots.reduce((promises, root) => promises.concat(findGitRoot(root)), [])
  );
  const hgRepos = await Promise.all(
    roots.reduce((promises, root) => promises.concat(findHgRoot(root)), [])
  );
  return {
    git: new Set(gitRepos.filter(notEmpty)),
    hg: new Set(hgRepos.filter(notEmpty))
  };
};

exports.findRepos = findRepos;
=======
 *
 */

// This is an arbitrary number. The main goal is to prevent projects with
// many roots (50+) from spawning too many processes at once.
const mutex = (0, (_throat || _load_throat()).default)(5);

const findGitRoot = dir =>
  mutex(() => (_git || _load_git()).default.getRoot(dir));
const findHgRoot = dir => mutex(() => (_hg || _load_hg()).default.getRoot(dir));

const getChangedFilesForRoots = (exports.getChangedFilesForRoots = (() => {
  var _ref = _asyncToGenerator(function*(roots, options) {
    const repos = yield findRepos(roots);

    const changedFilesOptions = Object.assign(
      {},
      {includePaths: roots},
      options
    );

    const gitPromises = Array.from(repos.git).map(function(repo) {
      return (_git || _load_git()).default.findChangedFiles(
        repo,
        changedFilesOptions
      );
    });

    const hgPromises = Array.from(repos.hg).map(function(repo) {
      return (_hg || _load_hg()).default.findChangedFiles(
        repo,
        changedFilesOptions
      );
    });

    const changedFiles = (yield Promise.all(
      gitPromises.concat(hgPromises)
    )).reduce(function(allFiles, changedFilesInTheRepo) {
      for (const file of changedFilesInTheRepo) {
        allFiles.add(file);
      }

      return allFiles;
    }, new Set());

    return {changedFiles: changedFiles, repos: repos};
  });

  return function getChangedFilesForRoots(_x, _x2) {
    return _ref.apply(this, arguments);
  };
})());

const findRepos = (exports.findRepos = (() => {
  var _ref2 = _asyncToGenerator(function*(roots) {
    const gitRepos = yield Promise.all(
      roots.reduce(function(promises, root) {
        return promises.concat(findGitRoot(root));
      }, [])
    );
    const hgRepos = yield Promise.all(
      roots.reduce(function(promises, root) {
        return promises.concat(findHgRoot(root));
      }, [])
    );

    return {
      git: new Set(gitRepos.filter(Boolean)),
      hg: new Set(hgRepos.filter(Boolean))
    };
  });

  return function findRepos(_x3) {
    return _ref2.apply(this, arguments);
  };
})());
>>>>>>> 2cfd330b (move react to root dir)
